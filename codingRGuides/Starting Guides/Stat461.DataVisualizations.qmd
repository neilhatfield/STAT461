---
title: "Data Visualizations"
author: "Neil J. Hatfield"
date-modified: now
latex-tinytex: true
format: 
  html:
    embed-resources: true
    number-sections: true
    code-annotations: below
    fig-align: center
    toc: true
    toc-depth: 4
    toc-location: right
    cap-location: top
    link-external-newwindow: true
execute: 
  echo: false
  warning: false
  cache: true
---

Welcome! This Getting Started guide focuses on Data Visualizations. I've woven R code with some key guidance and conventions throughout. Thus, even if you are not using R, I highly recommend that you read through the guide. If you are using R, I'll encourage you to try to mimic the code for yourself and recreate the examples. Then you can adapt the code to help you with other data collections (say, the data from HW #1.1).

An important think to remember as you read this guide is that this guide is *not* meant to be exhaustive. I am not going to cover every possible type of data visualization nor am I going to cover every possible way to create the same kind of data visualization in R. 

# Getting Ready

When getting ready to do anything in R, you'll always want to take a moment and ensure that you identify what packages and data you'll need. Then you should load those items. Again, a good habit to get into is to always start your R script (or your first code chunk) by loading packages, setting any global options, and loading data.

## Graphics Packages

When you use a statistical software package like Minitab, SPSS, JMP, or a spreadsheet program like Excel or Sheets, you are typically limited to the visualization tools in that program. In R, that isn't the case. There are many packages you can use to create data visualizations.  There are many packages that are dedicated to extending the graphing capabilities of base R such as `{ggplot2}`, `{lattice}`, `{plotly}`, `{Rgraphviz}`, and `{scatterplot3d}` to list a few. In addition to these, many packages will often contain functions that will create specialized graphs (e.g., the `qqPlot` function from the `{car}` package).

I'm going to focus on using the `{ggplot2}` package that is part of the `{tidyverse}`. This package has many nice tools and creates some nice looking data visualizations. I'll also make use of the `{car}` package.

```{r}
#| label: loadPackages
#| echo: true
#| results: hide
# Load useful packages ----
packages <- c("tidyverse", "car")
lapply(
  X = packages,
  FUN = library,
  character.only = TRUE,
  quietly = TRUE
)

```

## Load Data

I'm going to use the penguin data from the `{palmerpenguins}` package as well as a version of the Oreo data related to HW #1.1. As a reminder, here's how you load these both into R.

```{r}
#| label: loadData
#| echo: true
# Loading data into my session ----
## Palmer Penguin data
# install.packages("palmerpenguins")  
penguins <- palmerpenguins::penguins 

## Oreo Data (HW #1.1) 
oreoData <- read.table( 
  file = "https://raw.github.com/neilhatfield/STAT461/master/dataFiles/classDemoOreo.dat", 
  header = TRUE,
  sep = ","
) 

```

# Planning

Most people skip over one of the most important steps in creating data visualizations: __planning__. It is very easy to skip this step and jump straight into clicking buttons or running graphing commands. However, good data visualizations demand that not only do you think about the visualization but you think about how you are going to use and talk about what appears in the data visualization. By taking a few minutes to plan your data visualization, you'll be in a better position as a whole.

Here are some questions to ask yourself as you plan your data visualization:

+ What is your goal? What are you trying to do?
+ What data do you need? What data do you have?
    + Is the data tidy? Do you need to wrangle the data first?
+ What kind of visualization do you want to make?
+ What geometry(-ies) do you need for your visualization?
+ What goes into the framework of your visualization?
+ What goes into the content?
+ What do you need in terms of labels and scales?
+ Do you need multiple layers to the visualization?

:::{.callout-tip}
A good practice is to sketch what you're trying to create. This will help you think through the various elements of your visualization. Additionally, this can help you better ask others for help.
:::

## Data Wrangling

An important part of making a plan is to double check that you have the data you need and that the data is in a useful form. For this guide, I'm using the penguins data, which is ready to go, and some Oreo data, which isn't quite ready. The major thing that I need to do for my data is to tell R to treat the type of Oreo as a factor.

```{r}
#| label: makeFactor
#| echo: true
# Set the Type as a Factor ----
oreoData$Type <- as.factor(oreoData$Type)

```

# Creating Data Visualizations

Once you've made a plan, the next step is to actually create the data visualization. If you are using some another statistical software (e.g., Minitab) or spreadsheet program (e.g., Excel), I still encourage you to read the following. Doing so will help you better understand some of the most common kinds of data visualizations.

## Frequency Based Visualizations

One of the most common classes of data visualizations are those that are based upon how often we observe different values for a single case attribute we're interested in. Keep in mind that we can express frequency on several different scales. *Absolute Frequency* refers to a strict counting of cases in each value grouping while *Relative Frequency* measures what percentage or proportion of the data collection has each value. 

### Dot Plots

Perhaps the most simple form of a frequency histogram is that of a dot plot. @fig-dot1 provides an example of such a plot.

```{r}
#| label: fig-dot1
#| fig-cap: "Dot plot of Oreo Filling Mass (g)"
#| fig-alt: "Dots showing the filling mass in grams for 60 Oreos"
#| fig-height: 3
#| echo: true
# Dot Plot of Oreo Filling Mass ----
ggplot(
  data = oreoData, # <1>
  mapping = aes(x = Filling.Mass) # <2>
) +
  geom_dotplot( # <3>
    method = "histodot",
    binwidth = 0.1,
    right = FALSE,
    dotsize = 1
  ) +
  labs( # <4>
    # title = "Dot Plot of Oreo Filling Mass", # <5>
    x = "Filling Mass (g)"
  ) +
  theme_bw() + # <6>
  theme( # <7>
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )

```
1. The `data` argument of the `ggplot` command is how we send data to the visualization.
2. The `mapping` argument allows us to assign a column of our data to an aesthetic (`aes`) such as the horizontal (`x`) axis.
3. In the dot plot geometry (and others), we may need to play around with additional arguments to make the visual look good. 
4. We can define the labels of our plot with the `labs` call.
5. You need to either have a plot title OR a figure caption for every plot. Since I'm using figure captions, I've commented out the title.
6. This is a pre-defined theme that makes a classic background for the plot.
7. You can further customize your plot. Here I'm hiding the vertical (`y`) axis as this is unneeded in a dot plot.

Dot plots such as @fig-dot1 show *absolute frequencies* as each dot (i.e., a glyph) corresponds to a specific case (here, an Oreo cookie). The position of each dot is determined by the filling mass of that cookie. The `binwidth` argument creates bins of 0.1 grams. The cookies that are in the same bin will then stack on top of each other. 

While this visualization allows you to get a big picture view of your data, playing around the with arguments of the geometry (`geom_dotplot`) can be time consuming.

### Bar Charts

Many people are familiar with bar charts; they are a classic type of visualization. We can use either absolute or relative frequencies. An important difference between a bar chart and a dot plot is that bar charts *aggregate* our data. That is, while a dot plot shows the individual cases, the bar chart will hide them. Generally, bar charts are used with attributes that are categorical in nature such as the species of penguins or the type of Oreo.

```{r}
#| label: fig-bar1
#| fig-cap: "Bar plot of Penguin Species"
#| fig-alt: "Bar plot showing the absolute frequencies of penguin species"
#| fig-height: 3
#| echo: true
# Bar Plot of Penguin Species ----
ggplot(
  data = penguins,
  mapping = aes(x = species)
) +
  geom_bar( # <1>
    color = "black", # <2>
    fill = "blue" # <3>
  ) +
  labs(
    # title = "Bar plot of Penguin Species",
    x = "Species",
    y = "Freq."
  ) +
  theme_bw()

```
1. Use the `geom_bar` to create a bar plot.
2. The `color` argument for this geometry controls the color of the piping/edges of the bars.
3. The `fill` argument controls the color of the bars themselves.

@fig-bar1 shows an absolute frequency bar plot for the three species of penguins in the penguin data. Notice that the species appear alphabetically across the axis they were assigned to (the horizontal). This is the default behavior of `ggplot`. You can reverse the order or even impose your own order if you so desire.

If we want to make a relative frequency bar plot, we can do so with a quick adjustment to the code as shown in @fig-bar2.

```{r}
#| label: fig-bar2
#| fig-cap: "Relative Frequency Bar plot of Penguin Species"
#| fig-alt: "Bar plot showing the relative frequencies of penguin species"
#| fig-height: 3
#| echo: true
# Bar Plot of Penguin Species ----
ggplot(
  data = penguins,
  mapping = aes(x = species, y = after_stat(prop), group = 1) # <1>
) +
  geom_bar(
    color = "black",
    fill = "blue"
  ) +
  labs(
    # title = "Relative Frequency Bar plot of Penguin Species",
    x = "Species",
    y = "Relative Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    labels = scales::percent, # <2>
    expand = expansion(add = c(0, 0.03)) # <3>
  )

```
1. By specifying `y = after_stat(prop)` we tell R that we want relative frequencies (or proportions). To set the appropriate denominator, we use `group = 1` to combine all cases into one group.
2. The `labels` argument allows us to adjust the labels on the vertical axis. The `{scales}` package has an automated function for showing percentages.
3. The `expand` argument allows us to control buffer space above/below (or left/right) of our data. Here, I'm *adding* zero buffer below the bars and a 3% buffer above the top of the highest bar.

Something to notice is that @fig-bar1 and @fig-bar2 look identical to each other up to the scale of the vertical axis. This will be true any time you shift between absolute and relative frequencies: the general appearance will be the same. We like to use relative frequency forms when we need to make comparisons between collections that are not the same size. For example, comparing a set of 60 Oreo cookies to a set of just 20 cookies.

If you incorporate multiple attributes, you can create additional types of bar charts such as side-by-side or stacked bar charts. These are not covered in this guide.

### Histograms

Histograms are very similar to bar charts. In fact, we read the two types of plots in the same way. The key difference is what attributes we want to visualize. While bar charts start with categorical attributes, histograms start out with quantitative attributes (especially, continuous ones). Behind the scenes (i.e., the computer does this) the interval of values gets broken down into a set of bins and we count how many cases fall into each bin. 

```{r}
#| label: fig-hist1
#| fig-cap: "Histogram of Filling Mass"
#| fig-alt: "Histogram of Oreo filling masses"
#| fig-height: 3
#| echo: true
# Histogram of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_histogram( # <1>
    color = "black",
    fill = "blue",
    binwidth = 0.1,
    boundary = 0, # <2>
    closed = "left" # <3>
  ) +
  labs(
    # title = "Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    expand = expansion(add = c(0, 2)) # <4>
  )

```
1. For histograms we use the `geom_histogram` call.
2. The `boundary` argument allows us to set where we want to specify a particular bin edge to be set at. Alternatively, you can use `center` to specify a value you want to be the center of a bin. All other bins will adjust to this.
3. Most people are used to left-closed histograms: each bin contains the left-edge value up to the right-edge but not the right-edge value. By default, `{ggplot2}` does the reverse. This argument follows convention.
4. Here I'm adding two units of space above the tallest bar.

@fig-hist1 is an example histogram using the filling masses of the Oreo data. We can get some general impressions of our data collection and what values we've observed by looking at a histogram. To make a relative frequency histogram, we need to make similar changes as for the bar chart.

```{r}
#| label: fig-hist2
#| fig-cap: "Relative Frequency Histogram of Filling Mass"
#| fig-alt: "Relative Frequency Histogram of Oreo filling masses"
#| fig-height: 3
#| echo: true
# Histogram of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_histogram(
    mapping = aes(y = after_stat(count / sum(count))), # <1>
    color = "black",
    fill = "blue",
    binwidth = 0.1,
    boundary = 0,
    closed = "left"
  ) +
  labs(
    # title = "Relative Frequency Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Relative Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    labels = scales::percent,
    expand = expansion(add = c(0, 0.03))
  )

```
1. A `mapping` call inside `geom_histogram` lets us specify that we want to use the `after_stat` command to generate the relative frequencies for each bin.

#### Choosing Bin Width (Number of Bins)

Much like with dot plots, one of the biggest challenges for producing useful histograms is determining either the number of bins (the `bins` argument) or the width of each bin (the `binwidth` argument). You only need to set one of these two as the choice of one automatically determines the other. By default, `ggplot` will use 30 bins--but will produce a warning message that you should use a better number of bins. You can play around with your choices for either of these arguments and find the value that leads to the clearest histogram.

A statistician and a mathematician worked together to form what is known as the Freedman-Diaconis rule which can help you come up with a potentially useful bin width. You can define this in R as

```{r}
#| label: fdRule
#| echo: true
# Freedman-Diaconis Rule ----
fdRule <- function(x) {
  return(
    ifelse(
      test = IQR(x) == 0,
      yes =  0.1,
      no =  2 * IQR(x) / (length(x)^(1/3))
    )
  )
}
```

We can see this rule in action in @fig-hist3.

```{r}
#| label: fig-hist3
#| fig-cap: "Histogram of Filling Mass"
#| fig-alt: "Histogram of Oreo filling masses using the Freedman-Diaconis rule"
#| fig-height: 3
#| echo: true
# Histogram of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_histogram(
    color = "black",
    fill = "blue",
    binwidth = fdRule, # <1>
    boundary = 0,
    closed = "left"
  ) +
  labs(
    # title = "Relative Frequency Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Relative Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    expand = expansion(add = c(0, 2))
  )

```
1. Notice that after we've defined the `fdRule` function, we can call the function in the `binwidth` argument instead of assigning a numeric value.

As you compare @fig-hist1 and @fig-hist3, pay attention to how your descriptions change between them. In the former we might talk about the gaps between two groupings of values but in the later there are no longer any gaps. This highlights that your choice of bin width (or number of bins) is consequential. 

### Pie Charts

Another data visualization that people often mention are pie charts. Pie charts take the notion of a bar chart and plot things in a circular space. While in a bar chart we read the height of the bar to get the frequency value, pie charts work off of angle measures. That is, the measure of the each slices angle reflects the relative proportion of the whole. This pie charts great at relativistic comparisons between values but terrible for getting accurate amounts. A second drawback to pie charts deals with deciding which slice has a larger angle measure when they are close to each other.

If you absolutely want to create a pie chart, you can. However, you will need to do a little bit of data wrangling first.

```{r}
#| label: summarizeSpecies
#| echo: true
# Wrangle Penguin Data for Pie Chart ----
## We will use {dplyr} commands to help us
pieData <- penguins %>%
  group_by(species) %>%
  summarize(
    count = n()
  )

```

The above code allows us to get the counts that we will then use to make the pie chart.

```{r}
#| label: fig-pie1
#| fig-cap: "Pie Chart of Penguin Species"
#| fig-alt: "Pie chart of penguin species"
#| fig-height: 3
#| echo: true
# Pie Chart of Penguin Species ----
ggplot(
  data = pieData,
  mapping = aes(x = "", y = count, fill = species) # <1>
) +
  geom_bar(
    stat = "identity", # <2>
    color = "black" # <3>
  ) +
  coord_polar(theta = "y", start = 0) + # <4>
  labs(
    # title = "Pie Chart of Penguin Species",
    fill = "Species"
  ) + 
  theme_void() # <5>

```
1. We need to specify both an `x` and `y` component, even though the `x` component will be fixed. To color the slices, we need to map the species attribute to the `fill` aesthetic.
2. Given that we've already done the counting, we just need the bar geometry to make use of the values as is. This code achieves this.
3. Just as before the `color` argument will control the edging of the slices. Omit this argument if you don't want any borders.
4. To transform the bars into pie slices, we change to the polar coordinate system (instead of the Cartesian).
5. When making pie charts, use `theme_void`.

### Waffle Plots

A possible alternative to pie charts is to make a "square pie chart" known as a waffle plot. The core idea is to attempt to overcome the shortcomings of pie charts (namely, working with angle measure). In their most basic form, a waffle plot is a grid-like organization of glyphs. Each glyph can either represent an individual case OR could represent a certain proportion of the data collection. To create a waffle plot, you will need to have the `{waffle}` package installed on your machine (this is not covered by my `checkSetup` function).

```{r}
#| label: fig-waffle1
#| fig-cap: "Waffle Plot of Penguin Species"
#| fig-alt: "A proportional waffle plot of penguin species"
#| fig-height: 3
#| echo: true
# Create a waffle plot of penguin species ----
# install.package(waffle)
library(waffle)

ggplot(
  data = pieData,
  mapping = aes(fill = species, values = count)
) +
  geom_waffle( # <1>
    n_rows = 10,
    make_proportional = TRUE
  ) +
  labs(
    # title = "Waffle Plot of Penguin Species",
    fill = "Species"
  ) +
  theme_void() +
  coord_equal() # <2>

```
1. To use the waffle geometry, you must first install and load the `{waffle}` package.
2. To ensure that glyphs look square, we use the `coord_equal` command.


@fig-waffle1 shows a waffle plot for the penguins species data. For this visualization, I've opted to to the proportion route (via the `make_proportional = TRUE` argument). This means that each square in my 10 X 10 grid represents one percent of the data collection. If we instead wanted each square to represent an individual penguin, I'd use `make_proportional = FALSE` as shown in @fig-waffle2.

```{r}
#| label: fig-waffle2
#| fig-cap: "Waffle Plot of Penguin Species"
#| fig-alt: "A case-based waffle plot of penguin species"
#| fig-height: 3
#| echo: true
# Create a waffle plot of penguin species ----
# install.package(waffle)
library(waffle)

ggplot(
  data = pieData,
  mapping = aes(fill = species, values = count)
) +
  geom_waffle(
    n_rows = 8, # <1>
    make_proportional = FALSE
  ) +
  labs(
    # title = "Waffle Plot of Penguin Species",
    fill = "Species"
  ) +
  theme_void() +
  coord_equal()

```
1. We can alter how many rows appear in the waffle plot. I changed to 8 since 344 (the sample size of the penguin data) is a multiple of 8.

Waffle plots can allow us to see the break down of our data collection along the lines of qualitative/categorical attributes, much like a bar chart.

## Density Based Visualizations

A close cousin of the histogram is a density plot. Whereas a histogram shows the absolute/relative frequency of cases within different bins for a given sample, a density plot attempts to show the probability density for the underlying quantitative attribute. 

```{r}
#| label: fig-density1
#| fig-cap: "Density Plot of Filling Mass"
#| fig-alt: "Density plot of Oreo filling masses"
#| fig-height: 3
#| echo: true
# Density plot of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_density( # <1>
    color = "black",
    fill = "blue"
  ) +
  labs(
    # title = "Relative Frequency Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Density"
  ) +
  theme_bw() +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.05)) # <2>
  ) 

```
1. For density plots, use the `geom_density`.
2. Instead of adding a fixed amount of buffer you can also use a multiplier. Here, I'm expanding the upper bound by 5%.

@fig-density1 shows the density plot for the Oreo filling masses. You'll notice that at the left and right edges there are hard stops to the plot. By default the density plot will stop at the lower and upper extrema in the data. If you want to have the smoothing continue on, you'll need to adjust the limits with an additional command such as `scale_x_continuous(limits = c(lb, ub))` where you replace `lb` and `ub` with the numeric values for the new lower and upper bounds, respectively.

Density plots do not suffer from the same sensitivity to bin width as histograms do. However, they still limits. Inside of the `geom_density` there is an option that controls an aspect called bandwidth (`bw`). We can think about bandwidth as a way of adjusting how much of the data we look at to make the smooth curve as we move through the domain of filling masses. If we make bandwidth very large, then we use more the data making a shallow curve. If we use a small bandwidth, then we use less data, making the curve more spiked. A second important option in `geom_density` is the `kernel`. This is the function that gets used to help make the smooth curve; different kernels will result in different density plots for the same data.

:::{.callout-note}
Digging into both bandwidth and kernel choices are beyond what is necessary for Stat 461. For any instances in our class, use the defaults for these is sufficient.
:::

## Structural Visualizations

### Box Plots

## Visualizing Multiple Attributes

### Strip Charts

### Scatter Plots

### 2D Histograms

### Multivariate Box Plots

## Using Multiple Layers

## A Data Visualization Explorer

# Creating Figures in Markdown-Enabled Documents

# OLD

## Density Plots

A density plots are a smoothed version of a histogram that can help us think about the underlying population rather than the sample in front of us. Making one in `ggplot2` is fairly straight forward.

```{r densityPlot1}
#| echo = TRUE,
#| eval = TRUE,
#| fig.cap = "ggplot2 density plot of Oreo créme filling mass",
#| fig.height = 3

## Density Plot Example using ggplot2 ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_density(
    na.rm = TRUE,
    color = "black",
    fill = "springgreen"
  ) +
  theme_bw() +
  xlab("Filling mass (g)") +
  ylab("Density") +
  scale_x_continuous(
    expand = expansion(mult = 0, add = 0),
    limits = c(0, 10)
  ) +
  scale_y_continuous(
    expand = expansion(mult = 0, add = c(0, 0.025))
  )

```

Again, many of the arguments do the same thing as for the histograms/bar charts. Notice that instead of `col` you can use the whole word `color` (you can also use British spellings, `colour`) for the same effect. We changed which geometry we used to `geom_density` to get the density plot.

Notice that in addition to `scale_y_continuous` there's also `scale_x_continuous`. They do the same thing, just for different aspects of the plot. (There's also `scale_fill_*`, `scale_color_*` , etc.). The `limits` argument allows you to control to what extend the plot goes for each axis. These limits will then have the expansion applied to them (if any). If you omit `limits`, then R will figure out decent limits for your data.

A second way to create a density plot is with the `lattice` package.

```{r densityEx2}
#| echo = TRUE,
#| eval = TRUE,
#| fig.cap = "lattice density plot of créme filling mass",
#| fig.height = 3

## Density plot using lattice ----
lattice::densityplot(
  x = ~ Filling.Mass,
  data = oreoData,
  na.rm = TRUE,
  xlab = "Filling mass (g)",
  col = "black"
)
```

The `lattice` package's density plot includes all of the data points (the circles) along the plot's bottom. There is a new argument here: `x = ~ Filling.Mass`. The tilde, \~, is R's formula notation. We will be using throughout the semester. Using the formula notation `lattice`'s is similar to `ggplot2`'s `mapping` argument.

It is possible to use `ggplot2` to create a density plot like the `lattice` package. Think of this as a challenge for you to figure out how to do. Hint: you need to use two geometries.

## Box plots

As you might guess, making a box plot in `ggplot2` will involve using `geom_boxplot`.

```{r boxEx1}
#| echo = TRUE,
#| eval = TRUE,
#| fig.cap = "Box plot of créme filling mass by type",
#| fig.height = 3

## Box plot in ggplot2 ----
ggplot(
  data = oreoData,
  mapping = aes(x = Type, y = Filling.Mass, fill = Type)
) +
  geom_boxplot(
    na.rm = TRUE,
    linewidth = 0.2
  ) +
  theme_bw() +
  xlab(NULL) +
  ylab("Filling mass (g)") +
  theme(
    legend.position = "bottom"
  )

```

Notice that this time we defined three aesthetics: the horizontal axis (`x`) and `color` both get the Type attribute and the vertical axis (`y`) with créme filling mass. When you define the color aesthetic, R will find a color scheme for to use and create a legend to include in the plot. You can alter the color scheme used. You can also position the legend with the `legend.position` argument of the `theme` call. Notice that `xlab(NULL)` does not turn off the horizontal axis; rather just makes the label disappear.

If you don't have any groups for the box plot, then you can omit the extra aesthetics. For vertical box plots, assign the attribute to `y`; for horizontal box plots, use `x` instead.

I should point out that `ggplot2` did NOT produce a true box plot. Rather R created an *outlier* box plot. The whiskers only extend to 1.5 times the value of the *IQR* from the first and third quariltes. Any data values beyond that appear as solid dots. A true box plot has the whiskers extend to the values of the *sample minimum* and *sample maximum*.

## Strip Charts

Strip charts (or dot plots) are a type of scatter plot where instead of using two numeric attributes you use one numeric and one categorical. There are two ways to make strip charts: one using base R and the other using `ggplot2`.

The base R method is pretty easy to do:

```{r stripEx1}
#| echo = TRUE,
#| eval = TRUE,
#| fig.cap = "Strip chart for the Oreo data using base R",
#| fig.height = 3

## Strip chart in base R ----
stripchart(
  x = Filling.Mass ~ Type,
  data = oreoData,
  pch = 20,
  vertical = TRUE,
  xlab = "Type",
  ylab = "Filling mass (g)"
)
```

Notice that we used R's formula notation `Filling.Mass ~ Type`. The ordering is important: `Response ~ Factor` / `Numeric ~ ModelTerms`. The other new arguments here are `pch` which sets the shape for plotting the points. To see a list type `?points` in your R console. I typically use either 19 or 20.

To do the same thing in `ggplot2`:

```{r stripEx2}
#| echo = TRUE,
#| eval = TRUE,
#| fig.cap = "Strip chart for the Oreo data using ggplot2",
#| fig.height = 3

## Strip chart in ggplot2 ----
ggplot(
  data = oreoData,
  mapping = aes(x = Type, y = Filling.Mass, fill = Type)
) + 
  geom_point(size = 2) +
  theme_bw() +
  xlab("Type") +
  ylab("Filling mass (g)") +
  theme(
    legend.position = "none"
  )
```

## QQ Plots

Quantile-Quantile (QQ) plots are a useful tool to see whether or not your data follow a particular distribution. Much like density plots there are two ways you can create them; one using the `car` package and one (more complicated) using `ggplot2`.

```{r qqEx1}
#| echo = TRUE,
#| eval = TRUE,
#| fig.cap = "QQ plot for Oreo créme filling mass using car",
#| fig.height = 4

## QQ Plots using car ----
car::qqPlot(
  formula = ~ Filling.Mass,
  data = oreoData,
  distribution = "norm",
  envelope = 0.90,
  id = FALSE,
  pch = 19,
  ylab = "Empirical quantiles"
)
```

The `car` package's method produces a scatter plot of the empirical and theoretical quantiles for each point as well as plotting the line of perfect match (solid blue) as well as a confidence envelope (dashed blue lines).

Here the key arguments are the `formula` argument to specify the attribute's variable you want to explore, `data` to set which data set to use, `distribution` for which named distribution you want to reference (`"norm"` will give you the "normal" or Gaussian distribution), and `envelope` is where you specify the confidence level (if you don't want an envelope you can use `envelope = FALSE` to turn this off).

The `id` argument when set to `TRUE` will identify the two points with the most extreme vertical values. Often times these are not useful as the labels are the row indices. If you want to label them, set `id = TRUE` and store the plot in an object (i.e, `a <- car::qqPlot(...)`). The visualization will still get displayed but the row indices will not get printed out of context in your report.

To create a similar plot in `ggplot2`, you'll need to do the following:

```{r qqEx2}
#| echo = TRUE,
#| eval = TRUE,
#| fig.cap = "QQ plot for Oreo créme filling mass using ggplot2",
#| fig.align = 'center',
#| fig.height = 3,
#| fig.width = 6,
#| fig.pos = 'h'

## QQ Plot using ggplot2 ----
ggplot(
  data = oreoData,
  mapping = aes(sample = Filling.Mass)
) +
  geom_qq(
    na.rm = TRUE,
    distribution = stats::qnorm,
    dparams = list()
  ) + 
  geom_qq_line(
    na.rm = TRUE,
    distribution = stats::qnorm,
    dparams = list(),
    color = "blue"
  ) +
  theme_bw() +
  xlab("Theoretical quantiles") +
  ylab("Empirical quantiles")
```

You can add a confidence envelope through some data manipulation. Think of this as another challenge that you can choose to take up.

Notice that we used two geometries: `geom_qq` to plot the points and `geom_qq_line` to graph the line. For both of these we needed to define the aesthetic `sample` to house our data values we wanted to test. In addition, we need to specify which named distribution we're going to use as the theoretical reference. The `distribution` argument allows us to set this using the quantile functions built into the `stats` package that comes with all versions of R. You can see a list of the possible named distributions in the `stats` package help documentation (jump to the Q's).

The `dparams` argument is where you can specify particular parameters. Notice that we left ours as `list()`. This says to use the defaults for the named distribution. In our case, this would be an Expected Value of 1 and a Standard Deviation of 1. Suppose that you wanted to test whether data followed a normal/Gaussian distribution with Expected Value of 50 and Standard Deviation 5, you would then set `dparams = list(mu = 50, sd = 5)`. R would then use that distribution to make the plot.

# Figure Options in R Markdown

There are a variety of options that you can apply to your data visualizations in R Markdown. If you aren't using R Markdown, your visualizations will appear in the Plots window in the lower-right of RStudio. You can click the Export button and copy the plot to your clipboard or save as a file. You can then put that picture into Word or Google Docs. You will then manipulate the following aspects there.

## Basic Format

All of the figure options in R Markdown will need to be listed in the chunk options for the code chunk that creates the visualization.

When you create a chunk, you should have a some text inside of a set of curly braces immediately after the opening three graves. These are the chunk options. The first thing should be a lower case r to set the language, followed by a space, and then the *unique* name you're going to give that chunk. You will then place a comma after the name and begin listing the options you want. Here are the options for the very first histogram I created in this guide: `{r histEx1, echo=TRUE, eval=TRUE, fig.cap="Histogram of Oreo Créme Filling Mass"}`.

Both `echo` and `eval` don't deal with the visualization, just whether to print the code (`echo`) and run the code (`eval`). You can omit them; the homework template has these predefined for you. However, `fig.cap` is a figure option. If you wanted to include more figure options, you just keep adding to the list: `{r histEx1, fig.align='center', fig.height=3, fig.width=6, fig.cap="QQ plot for Oreo créme filling mass using ggplot2", fig.pos='h'}`. The order does not matter. There are many different ones that you can use but I'm going to focus on what I feel are the most useful ones.

Alternatively, you can list each of the options just after you start a code chunk. You would have something like the following:

```{r altCodeOptions, echo=TRUE, eval=FALSE}
{r histEx1}
#| echo = TRUE,
#| eval = TRUE,
#| fig.cap = "Histogram of Oreo Créme Filling Mass"
```

Each option goes on it's own line, which starts with `#|`. You will need to end each line (except the last) with a comma.

## Alignment

Alignment refers to whether the visualization appears to the left, center, or right of the page horizontally. Almost uniformly, data visualizations should appear centered. To do this, you would need to set `fig.align='center'` in each code chunk where a visualization gets made. However, you can also set this as a standard for your entire document:

```{r defaultEx1, echo=TRUE, eval=FALSE}
# Setting options for your document ----
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.align = "center"
)
```

The above default are part of the homework template and will make all visualizations centered for you.

## Size

There are two aspects to size for a visualization: height and width. All visualizations (including any legends) will be inside of a rectangle hence these two dimensions. The `fig.height` will control how tall this rectangle is while `fig.width` will control how wide. Both of these options are expecting a single number which is understood to be a number of *inches*. Thus, `fig.height=2, fig.width=4` will create a visualization that is 2 inches tall and 4 inches wide.

## Caption

The `fig.cap` option adds a caption to your visualization AND will put "Figure \#" out in front. This is consistent with many publication standards. If you omit the `fig.cap` option, then your visualization will not get a label. In such cases, be sure to add a title to your visualizations.

Your caption should appear in quotation marks just after the equals sign: `fig.cap="QQ plot for Oreo créme filling mass using ggplot2"`. Captions should describe the visualization by stating what kind of visualization and of what data. Try not to be overly wordy with your captions.

### Referencing

One of the most useful aspects about using `fig.cap` is that your figures become numbered and referenceable. Have you ever read something and you come across something like "As shown in Figure 3.1 we can see..."? This is an example of referencing a figure. The computer figures out the appropriate number for you...provided you've set up a caption for the visualization.

In R Markdown, you need to have two things first: you have to name your code chunk and provide something as `fig.cap`. Once you have those things, you can that visualization. Start by typing the word "Figure" and then`\ref{fig:chunkName}`. When you knit your file, R will replace the ref code with the appropriate value. For example, if I were to type "Figure `\ref{fig:histEx1}`", I will get Figure \ref{fig:histEx1}---the reference to the first histogram.

You can add captions, auto numbered labels, and cross references in programs like Word. From the Insert menu select caption to set up what you want. To add a reference to a figure, select Cross-reference from the Insert menu, select the appropriate type and then the correct figure. Do set the cross reference to only include the label and number, not the whole caption.

## Position

The last option I'm going to mention is one of the trickier ones to use; `fig.pos` *attempts* to control of the location of the visualization. When you knit the document, R will attempt to find the optimal location for the visualization. You can attempt to override this by setting the value of `fig.pos`. For example, `fig.pos='h'` says "hey, I want the visualization the appear "here" in my document. R will attempt to do that but if your figure is too large for the space at that place, your visualization will be moved (typically, the top of the next page).

# Final Remarks

Hopefully as you've gone through this guide, you have a better idea of how to make just a few of the many different data visualizations possible in R. Further, I hope that you're getting a better idea of how to use R Markdown to write code to your advantage. Practicing these examples is the best way to improve your fluency. For some additional datasets to work with, feel free to explore the following data sets:

-   Motor Trend Car Road Tests---access with `data(mtcars)`
-   Weight versus Age of Chicks on Different Diets---access with `data(ChickWeight)`
-   Effectiveness of Insect Sprays---access with `data(InsectSprays)`
-   The Iris data set---access with `data(iris)`
-   Palmer Penguin Data---install the `palmerpenguins` package first, then access with `palmerpenguins::penguins`

This concludes this guide to data visualizations in R/RStudio.

{{< pagebreak >}}

# Code Appendix

```{r codeAppend, ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```