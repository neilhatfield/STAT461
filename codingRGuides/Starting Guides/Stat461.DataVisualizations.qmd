---
title: "Data Visualizations"
author: "Neil J. Hatfield"
date-modified: now
latex-tinytex: true
format: 
  html:
    embed-resources: true
    number-sections: true
    code-annotations: below
    fig-align: center
    toc: true
    toc-depth: 4
    toc-location: right
    cap-location: top
    link-external-newwindow: true
execute: 
  echo: false
  warning: false
---

Welcome! This Getting Started guide focuses on Data Visualizations. I've woven R code with some key guidance and conventions throughout. Thus, even if you are not using R, I highly recommend that you read through the guide. If you are using R, I'll encourage you to try to mimic the code for yourself and recreate the examples. Then you can adapt the code to help you with other data collections (say, the data from HW #1.1).

An important think to remember as you read this guide is that this guide is *not* meant to be exhaustive. I am not going to cover every possible type of data visualization nor am I going to cover every possible way to create the same kind of data visualization in R. 

# Getting Ready

When getting ready to do anything in R, you'll always want to take a moment and ensure that you identify what packages and data you'll need. Then you should load those items. Again, a good habit to get into is to always start your R script (or your first code chunk) by loading packages, setting any global options, and loading data.

## Graphics Packages

When you use a statistical software package like Minitab, SPSS, JMP, or a spreadsheet program like Excel or Sheets, you are typically limited to the visualization tools in that program. In R, that isn't the case. There are many packages you can use to create data visualizations.  There are many packages that are dedicated to extending the graphing capabilities of base R such as `{ggplot2}`, `{lattice}`, `{plotly}`, `{Rgraphviz}`, and `{scatterplot3d}` to list a few. In addition to these, many packages will often contain functions that will create specialized graphs (e.g., the `qqPlot` function from the `{car}` package).

I'm going to focus on using the `{ggplot2}` package that is part of the `{tidyverse}`. This package has many nice tools and creates some nice looking data visualizations. I'll also make use of the `{car}` package.

```{r}
#| label: loadPackages
#| echo: true
#| results: hide
# Load useful packages ----
packages <- c("tidyverse", "car")
lapply(
  X = packages,
  FUN = library,
  character.only = TRUE,
  quietly = TRUE
)

```

## Load Data

I'm going to use the penguin data from the `{palmerpenguins}` package as well as a version of the Oreo data related to HW #1.1. As a reminder, here's how you load these both into R.

```{r}
#| label: loadData
#| echo: true
# Loading data into my session ----
## Palmer Penguin data
# install.packages("palmerpenguins")  
penguins <- palmerpenguins::penguins 

## Oreo Data (HW #1.1) 
oreoData <- read.table( 
  file = "https://raw.github.com/neilhatfield/STAT461/master/dataFiles/classDemoOreo.dat", 
  header = TRUE,
  sep = ","
) 

```

# Planning

Most people skip over one of the most important steps in creating data visualizations: __planning__. It is very easy to skip this step and jump straight into clicking buttons or running graphing commands. However, good data visualizations demand that not only do you think about the visualization but you think about how you are going to use and talk about what appears in the data visualization. By taking a few minutes to plan your data visualization, you'll be in a better position as a whole.

Here are some questions to ask yourself as you plan your data visualization:

+ What is your goal? What are you trying to do?
+ What data do you need? What data do you have?
    + Is the data tidy? Do you need to wrangle the data first?
+ What kind of visualization do you want to make?
+ What geometry(-ies) do you need for your visualization?
+ What goes into the framework of your visualization?
+ What goes into the content?
+ What do you need in terms of labels and scales?
+ Do you need multiple layers to the visualization?

:::{.callout-tip}
A good practice is to sketch what you're trying to create. This will help you think through the various elements of your visualization. Additionally, this can help you better ask others for help.
:::

## Data Wrangling

An important part of making a plan is to double check that you have the data you need and that the data is in a useful form. For this guide, I'm using the penguins data, which is ready to go, and some Oreo data, which isn't quite ready. The major thing that I need to do for my data is to tell R to treat the type of Oreo as a factor.

```{r}
#| label: makeFactor
#| echo: true
# Set the Type as a Factor ----
oreoData$Type <- as.factor(oreoData$Type)

```

# Creating Data Visualizations

Once you've made a plan, the next step is to actually create the data visualization. If you are using some another statistical software (e.g., Minitab) or spreadsheet program (e.g., Excel), I still encourage you to read the following. Doing so will help you better understand some of the most common kinds of data visualizations.

## Frequency Based Visualizations

One of the most common classes of data visualizations are those that are based upon how often we observe different values for a single case attribute we're interested in. Keep in mind that we can express frequency on several different scales. *Absolute Frequency* refers to a strict counting of cases in each value grouping while *Relative Frequency* measures what percentage or proportion of the data collection has each value. 

### Dot Plots

Perhaps the most simple form of a frequency histogram is that of a dot plot. @fig-dot1 provides an example of such a plot.

```{r}
#| label: fig-dot1
#| fig-cap: "Dot plot of Oreo Filling Mass (g)"
#| fig-alt: "Dots showing the filling mass in grams for 60 Oreos"
#| fig-height: 3
#| echo: true
#| aria-describedby: dot1LD
# Dot Plot of Oreo Filling Mass ----
ggplot(
  data = oreoData, # <1>
  mapping = aes(x = Filling.Mass) # <2>
) +
  geom_dotplot( # <3>
    method = "histodot",
    binwidth = 0.1,
    right = FALSE,
    dotsize = 1
  ) +
  labs( # <4>
    # title = "Dot Plot of Oreo Filling Mass", # <5>
    x = "Filling Mass (g)"
  ) +
  theme_bw() + # <6>
  theme( # <7>
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )

```
1. The `data` argument of the `ggplot` command is how we send data to the visualization.
2. The `mapping` argument allows us to assign a column of our data to an aesthetic (`aes`) such as the horizontal (`x`) axis.
3. In the dot plot geometry (and others), we may need to play around with additional arguments to make the visual look good. 
4. We can define the labels of our plot with the `labs` call.
5. You need to either have a plot title OR a figure caption for every plot. Since I'm using figure captions, I've commented out the title.
6. This is a pre-defined theme that makes a classic background for the plot.
7. You can further customize your plot. Here I'm hiding the vertical (`y`) axis as this is unneeded in a dot plot.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=dot1LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

Dot plots such as @fig-dot1 show *absolute frequencies* as each dot (i.e., a glyph) corresponds to a specific case (here, an Oreo cookie). The position of each dot is determined by the filling mass of that cookie. The `binwidth` argument creates bins of 0.1 grams. The cookies that are in the same bin will then stack on top of each other. 

While this visualization allows you to get a big picture view of your data, playing around the with arguments of the geometry (`geom_dotplot`) can be time consuming.

### Bar Charts

Many people are familiar with bar charts; they are a classic type of visualization. We can use either absolute or relative frequencies. An important difference between a bar chart and a dot plot is that bar charts *aggregate* our data. That is, while a dot plot shows the individual cases, the bar chart will hide them. Generally, bar charts are used with attributes that are categorical in nature such as the species of penguins or the type of Oreo.

```{r}
#| label: fig-bar1
#| fig-cap: "Bar plot of Penguin Species"
#| fig-alt: "Bar plot showing the absolute frequencies of penguin species"
#| fig-height: 3
#| echo: true
#| aria-describedby: bar1LD
# Bar Plot of Penguin Species ----
ggplot(
  data = penguins,
  mapping = aes(x = species)
) +
  geom_bar( # <1>
    color = "black", # <2>
    fill = "blue" # <3>
  ) +
  labs(
    # title = "Bar plot of Penguin Species",
    x = "Species",
    y = "Freq."
  ) +
  theme_bw()

```
1. Use the `geom_bar` to create a bar plot.
2. The `color` argument for this geometry controls the color of the piping/edges of the bars.
3. The `fill` argument controls the color of the bars themselves.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=bar1LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

@fig-bar1 shows an absolute frequency bar plot for the three species of penguins in the penguin data. Notice that the species appear alphabetically across the axis they were assigned to (the horizontal). This is the default behavior of `ggplot`. You can reverse the order or even impose your own order if you so desire.

If we want to make a relative frequency bar plot, we can do so with a quick adjustment to the code as shown in @fig-bar2.

```{r}
#| label: fig-bar2
#| fig-cap: "Relative Frequency Bar plot of Penguin Species"
#| fig-alt: "Bar plot showing the relative frequencies of penguin species"
#| fig-height: 3
#| echo: true
#| aria-describedby: bar2LD
# Bar Plot of Penguin Species ----
ggplot(
  data = penguins,
  mapping = aes(x = species, y = after_stat(prop), group = 1) # <1>
) +
  geom_bar(
    color = "black",
    fill = "blue"
  ) +
  labs(
    # title = "Relative Frequency Bar plot of Penguin Species",
    x = "Species",
    y = "Relative Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    labels = scales::percent, # <2>
    expand = expansion(add = c(0, 0.03)) # <3>
  )

```
1. By specifying `y = after_stat(prop)` we tell R that we want relative frequencies (or proportions). To set the appropriate denominator, we use `group = 1` to combine all cases into one group.
2. The `labels` argument allows us to adjust the labels on the vertical axis. The `{scales}` package has an automated function for showing percentages.
3. The `expand` argument allows us to control buffer space above/below (or left/right) of our data. Here, I'm *adding* zero buffer below the bars and a 3% buffer above the top of the highest bar.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=bar2LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

Something to notice is that @fig-bar1 and @fig-bar2 look identical to each other up to the scale of the vertical axis. This will be true any time you shift between absolute and relative frequencies: the general appearance will be the same. We like to use relative frequency forms when we need to make comparisons between collections that are not the same size. For example, comparing a set of 60 Oreo cookies to a set of just 20 cookies.

If you incorporate multiple attributes, you can create additional types of bar charts such as side-by-side or stacked bar charts. These are not covered in this guide.

### Histograms

Histograms are very similar to bar charts. In fact, we read the two types of plots in the same way. The key difference is what attributes we want to visualize. While bar charts start with categorical attributes, histograms start out with quantitative attributes (especially, continuous ones). Behind the scenes (i.e., the computer does this) the interval of values gets broken down into a set of bins and we count how many cases fall into each bin. 

```{r}
#| label: fig-hist1
#| fig-cap: "Histogram of Filling Mass"
#| fig-alt: "Histogram of Oreo filling masses"
#| fig-height: 3
#| echo: true
#| aria-describedby: hist1LD
# Histogram of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_histogram( # <1>
    color = "black",
    fill = "blue",
    binwidth = 0.1,
    boundary = 0, # <2>
    closed = "left" # <3>
  ) +
  labs(
    # title = "Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    expand = expansion(add = c(0, 2)) # <4>
  )

```
1. For histograms we use the `geom_histogram` call.
2. The `boundary` argument allows us to set where we want to specify a particular bin edge to be set at. Alternatively, you can use `center` to specify a value you want to be the center of a bin. All other bins will adjust to this.
3. Most people are used to left-closed histograms: each bin contains the left-edge value up to the right-edge but not the right-edge value. By default, `{ggplot2}` does the reverse. This argument follows convention.
4. Here I'm adding two units of space above the tallest bar.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=hist1LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

@fig-hist1 is an example histogram using the filling masses of the Oreo data. We can get some general impressions of our data collection and what values we've observed by looking at a histogram. To make a relative frequency histogram, we need to make similar changes as for the bar chart.

```{r}
#| label: fig-hist2
#| fig-cap: "Relative Frequency Histogram of Filling Mass"
#| fig-alt: "Relative Frequency Histogram of Oreo filling masses"
#| fig-height: 3
#| echo: true
#| aria-describedby: hist2LD
# Histogram of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_histogram(
    mapping = aes(y = after_stat(count / sum(count))), # <1>
    color = "black",
    fill = "blue",
    binwidth = 0.1,
    boundary = 0,
    closed = "left"
  ) +
  labs(
    # title = "Relative Frequency Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Relative Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    labels = scales::percent,
    expand = expansion(add = c(0, 0.03))
  )

```
1. A `mapping` call inside `geom_histogram` lets us specify that we want to use the `after_stat` command to generate the relative frequencies for each bin.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=hist2LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

#### Choosing Bin Width (Number of Bins)

Much like with dot plots, one of the biggest challenges for producing useful histograms is determining either the number of bins (the `bins` argument) or the width of each bin (the `binwidth` argument). You only need to set one of these two as the choice of one automatically determines the other. By default, `ggplot` will use 30 bins--but will produce a warning message that you should use a better number of bins. You can play around with your choices for either of these arguments and find the value that leads to the clearest histogram.

A statistician and a mathematician worked together to form what is known as the Freedman-Diaconis rule which can help you come up with a potentially useful bin width. You can define this in R as

```{r}
#| label: fdRule
#| echo: true
# Freedman-Diaconis Rule ----
fdRule <- function(x) {
  return(
    ifelse(
      test = IQR(x) == 0,
      yes =  0.1,
      no =  2 * IQR(x) / (length(x)^(1/3))
    )
  )
}
```

We can see this rule in action in @fig-hist3.

```{r}
#| label: fig-hist3
#| fig-cap: "Histogram of Filling Mass"
#| fig-alt: "Histogram of Oreo filling masses using the Freedman-Diaconis rule"
#| fig-height: 3
#| echo: true
#| aria-describedby: hist3LD
# Histogram of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_histogram(
    color = "black",
    fill = "blue",
    binwidth = fdRule, # <1>
    boundary = 0,
    closed = "left"
  ) +
  labs(
    # title = "Relative Frequency Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Relative Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    expand = expansion(add = c(0, 2))
  )

```
1. Notice that after we've defined the `fdRule` function, we can call the function in the `binwidth` argument instead of assigning a numeric value.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=hist3LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

As you compare @fig-hist1 and @fig-hist3, pay attention to how your descriptions change between them. In the former we might talk about the gaps between two groupings of values but in the later there are no longer any gaps. This highlights that your choice of bin width (or number of bins) is consequential. 

:::{.callout-caution}
A common mistake that people make with histograms is to use the histogram to justify a claim that data follow a typical distribution. For example, upon seeing a symmetric, bell-shaped histogram and declaring that the data follow a Gaussian or "Normal" distribution. Unfortunately, this is __NOT__ accurate. At best, we can use a histogram as evidence *against* our data following a particular distribution. A histogram with a strong positive skew would support our claim that the data *do not* follow a Gaussian or "Normal" distribution.
:::

### Pie Charts

Another data visualization that people often mention are pie charts. Pie charts take the notion of a bar chart and plot things in a circular space. While in a bar chart we read the height of the bar to get the frequency value, pie charts work off of angle measures. That is, the measure of the each slices angle reflects the relative proportion of the whole. This pie charts great at relativistic comparisons between values but terrible for getting accurate amounts. A second drawback to pie charts deals with deciding which slice has a larger angle measure when they are close to each other.

If you absolutely want to create a pie chart, you can. However, you will need to do a little bit of data wrangling first.

```{r}
#| label: summarizeSpecies
#| echo: true
# Wrangle Penguin Data for Pie Chart ----
## We will use {dplyr} commands to help us
pieData <- penguins %>%
  group_by(species) %>%
  summarize(
    count = n()
  )

```

The above code allows us to get the counts that we will then use to make the pie chart.

```{r}
#| label: fig-pie1
#| fig-cap: "Pie Chart of Penguin Species"
#| fig-alt: "Pie chart of penguin species"
#| fig-height: 3
#| echo: true
#| aria-describedby: pie1LD
# Pie Chart of Penguin Species ----
ggplot(
  data = pieData,
  mapping = aes(x = "", y = count, fill = species) # <1>
) +
  geom_bar(
    stat = "identity", # <2>
    color = "black" # <3>
  ) +
  coord_polar(theta = "y", start = 0) + # <4>
  labs(
    # title = "Pie Chart of Penguin Species",
    fill = "Species"
  ) + 
  theme_void() # <5>

```
1. We need to specify both an `x` and `y` component, even though the `x` component will be fixed. To color the slices, we need to map the species attribute to the `fill` aesthetic.
2. Given that we've already done the counting, we just need the bar geometry to make use of the values as is. This code achieves this.
3. Just as before the `color` argument will control the edging of the slices. Omit this argument if you don't want any borders.
4. To transform the bars into pie slices, we change to the polar coordinate system (instead of the Cartesian).
5. When making pie charts, use `theme_void`.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=pie1LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

### Waffle Plots

A possible alternative to pie charts is to make a "square pie chart" known as a waffle plot. The core idea is to attempt to overcome the shortcomings of pie charts (namely, working with angle measure). In their most basic form, a waffle plot is a grid-like organization of glyphs. Each glyph can either represent an individual case OR could represent a certain proportion of the data collection. To create a waffle plot, you will need to have the `{waffle}` package installed on your machine (this is not covered by my `checkSetup` function).

```{r}
#| label: fig-waffle1
#| fig-cap: "Waffle Plot of Penguin Species"
#| fig-alt: "A proportional waffle plot of penguin species"
#| fig-height: 3
#| echo: true
#| aria-describedby: waffle1LD
# Create a waffle plot of penguin species ----
# install.package(waffle)
library(waffle)

ggplot(
  data = pieData,
  mapping = aes(fill = species, values = count)
) +
  geom_waffle( # <1>
    n_rows = 10,
    make_proportional = TRUE
  ) +
  labs(
    # title = "Waffle Plot of Penguin Species",
    fill = "Species"
  ) +
  theme_void() +
  coord_equal() # <2>

```
1. To use the waffle geometry, you must first install and load the `{waffle}` package.
2. To ensure that glyphs look square, we use the `coord_equal` command.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=waffle1LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

@fig-waffle1 shows a waffle plot for the penguins species data. For this visualization, I've opted to to the proportion route (via the `make_proportional = TRUE` argument). This means that each square in my 10 X 10 grid represents one percent of the data collection. If we instead wanted each square to represent an individual penguin, I'd use `make_proportional = FALSE` as shown in @fig-waffle2.

```{r}
#| label: fig-waffle2
#| fig-cap: "Waffle Plot of Penguin Species"
#| fig-alt: "A case-based waffle plot of penguin species"
#| fig-height: 3
#| echo: true
#| aria-describedby: waffle2LD
# Create a waffle plot of penguin species ----
# install.package(waffle)
library(waffle)

ggplot(
  data = pieData,
  mapping = aes(fill = species, values = count)
) +
  geom_waffle(
    n_rows = 8, # <1>
    make_proportional = FALSE
  ) +
  labs(
    # title = "Waffle Plot of Penguin Species",
    fill = "Species"
  ) +
  theme_void() +
  coord_equal()

```
1. We can alter how many rows appear in the waffle plot. I changed to 8 since 344 (the sample size of the penguin data) is a multiple of 8.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=waffle2LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

Waffle plots can allow us to see the break down of our data collection along the lines of qualitative/categorical attributes, much like a bar chart.

### Density Based Visualizations

A close cousin of the histogram is a density plot. Whereas a histogram shows the absolute/relative frequency of cases within different bins for a given sample, a density plot attempts to show the probability density for the underlying quantitative attribute. 

```{r}
#| label: fig-density1
#| fig-cap: "Density Plot of Filling Mass"
#| fig-alt: "Density plot of Oreo filling masses"
#| fig-height: 3
#| echo: true
#| aria-describedby: density1LD
# Density plot of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_density( # <1>
    color = "black",
    fill = "blue"
  ) +
  labs(
    # title = "Relative Frequency Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Density"
  ) +
  theme_bw() +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.05)) # <2>
  ) 

```
1. For density plots, use the `geom_density`.
2. Instead of adding a fixed amount of buffer you can also use a multiplier. Here, I'm expanding the upper bound by 5%.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=density1LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

@fig-density1 shows the density plot for the Oreo filling masses. You'll notice that at the left and right edges there are hard stops to the plot. By default the density plot will stop at the lower and upper extrema in the data. If you want to have the smoothing continue on, you'll need to adjust the limits with an additional command such as `scale_x_continuous(limits = c(lb, ub))` where you replace `lb` and `ub` with the numeric values for the new lower and upper bounds, respectively.

Density plots do not suffer from the same sensitivity to bin width as histograms do. However, they still limits. Inside of the `geom_density` there is an option that controls an aspect called bandwidth (`bw`). We can think about bandwidth as a way of adjusting how much of the data we look at to make the smooth curve as we move through the domain of filling masses. If we make bandwidth very large, then we use more the data making a shallow curve. If we use a small bandwidth, then we use less data, making the curve more spiked. A second important option in `geom_density` is the `kernel`. This is the function that gets used to help make the smooth curve; different kernels will result in different density plots for the same data.

:::{.callout-note}
Digging into both bandwidth and kernel choices are beyond what is necessary for Stat 461. For any instances in our class, use the defaults for these is sufficient.
:::

## Structural Visualizations

The preceding kinds of data visualizations draw upon frequency of case occurrence. These count-based aspects work well with attributes that are categorical/qualitative or quantitative in nature. Suppose that we wanted to draw upon the inherent ordering of the underlying case attribute to help us learn more about our data. When we used the frequency-based visualizations with quantities, the conventions of how we plot kicked in help put the values of the case attribute into numeric order. However, there is a kind of data visualization that was originally created to help highlight the ordinal structure: the box plot.

Many people often think about the box plot as just a visual representation of [Tukey's] Five Number Summery. The standard box plot does show these values but the purpose is to show much, much more.

### The [Standard] Box Plot

```{r}
#| label: fig-box1
#| fig-cap: "[Standard] Box Plot for Filling Mass"
#| fig-alt: "A standard box plot for the filling mass of oreos"
#| fig-height: 3
#| echo: true
#| aria-describedby: box1LD
# Standard box plot of Oreo filling mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass) 
) +
  geom_boxplot( # <1>
    coef = Inf, # <2>
    staplewidth = 0.1 # <3>
  ) +
  labs(
    # title = "[Standard] Box Plot for Filling Mass",
    x = "Filling mass (g)",
    y = NULL # <4>
  ) +
  theme_bw() +
  theme( # <5>
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line.y = element_blank()
  )

```
1. To invoke the box plot geometry we use the `geom_boxplot` command.
2. For a [standard] box plot set `coef = Inf`.
3. Traditionally, whiskers end with hash marks called staples. However, more modern box plots do away with them (the default). If you want them you can use the `staplewidth` argument as shown here.
4. For a horizontal box plot, map the case attribute to `x` and tell `y` to have no (`NULL`) label. If you want a vertical box plot, use swap `x` and `y` in the code.
5. These command will make a cleaner box plot by getting rid of elements that don't have any meaning. For a vertical box plot, change the `.y` to `.x` as you swap the other `x` and `y` references.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=box1LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

@fig-box1 is a standard box plot in the sense that the whiskers (the lines) extend to the values of the *Sample Minimum* ($Q_0$) and *Sample Maximum* ($Q_4$). A box plot demonstrates the structure of a data collection in multiple ways. First, we can observe how the data collection lies across the continuum of the case attribute (much like a histogram does). Second, the box plot also shows us what portions of the continuum of values are captured by each of the ordered quarters of the collection. In @fig-box1, the first quarter covers the intervals $[2.25, 3.25]$, approximately. The third quarter approximately covers $[4.55, 6.4]$. We can do the same with the second and fourth quarters. Third, we can use where the quarters lie along with the fact that they contain *roughly* the same number of cases talk about density. The first quarter is more dense than the third quarter, suggesting that the first quarter has less variation between the cases than the third quarter. Finally, we can also use the box plot to get a sense of symmetry by comparing the two halves of the plot. We can split the box plot along the the thicker black line inside of the box that represents the value of the *Sample Median*). @fig-box1 shows that the filling masses of Oreos might have a some positive skewness (we need to cover more the filling mass axis for values larger than the value of the *Sample Median*).

### Outlier Box Plots (Schematic Plots)

A second form of box plots is sometimes referred to as an "outlier box plot" although this name is a bit misleading. Tukey original referred to these as *Schematic Plots*. They differ from standard box plots in that the whiskers will no longer reach the values of the *Sample Minimum* and *Sample Maximum*. Rather, they will extend to the appropriate hinge. Any cases whose values are beyond the hinges are considered as *outlying cases*. Such cases are not necessarily [potential] outliers as their classification as outlying depends upon our choice for a multiplier (i.e., the `coef` argument).

```{r}
#| label: fig-box2
#| fig-cap: "Schematic Plot for Filling Mass"
#| fig-alt: "A schematic plot for the oreo filling mass"
#| fig-height: 3
#| echo: true
#| aria-describedby: box2LD
# Schematic plot of Oreo filling mass ----
## I'm going to add a fake Oreo that has 20 grams of filling
oreoData %>%
  tibble::add_row(Filling.Mass = 20, Type = "Extra") %>% # <1>
ggplot( # <2>
  mapping = aes(x = Filling.Mass) 
) +
  geom_boxplot(
    coef = 1.5 # <3>
  ) +
  labs(
    # title = "Schematic Plot for Penguin Body Mass",
    x = "Filling mass (g)",
    y = NULL
  ) +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line.y = element_blank()
  )

```
1. Given how I've used the `add_row` command, the extra row only exists in this one bit of code and isn't permanently added to the data.
2. As I am piping in the data frame (via `%>%`), I do not need to list the `data` argument in the `ggplot` call.
3. The most common multiplier is 1.5 but you can use other values if you so choose.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=box2LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

@fig-box2 shows the schematic plot for the Oreo filling masses with the addition of a fake Oreo with 20 grams of filling. Notice that this case appears as a black dot in @fig-box2. If we omitted this fake cookie, our schematic plot would actually look just like the standard box plot of @fig-box1. Any time that there are no outlying cases under your choice of rule, the schematic plot will automatically revert to a standard box plot.

### Other Variations of the Box Plot

There are a number of additional variations of box plots such as variable width of the boxes, adding notches to the boxes and adding on additional cut points (e.g., the first and seventh octiles). 

## Visualizing Multiple Attributes

The data visualizations that we've looked at so far have all focused on a single case attribute at a time. Much of the time, we have several case attributes and we are wanting to explore the relationship between them. The following visualizations do just that.

### Strip Charts

Let's start by attempting to observe how our cases fall when we look at a quantitative attribute and a categorical/qualitative. A strip chart is a great tool for this.

```{r}
#| label: fig-strip1
#| fig-cap: "Strip Chart of Oreo Filling Mass by Type"
#| fig-alt: "Strip chart of oreo filling mass by type"
#| fig-height: 3
#| echo: true
#| aria-describedby: strip1LD
# Strip chart of Oreo filling mass by type ----
ggplot(
  data = oreoData,
  mapping = aes(x = Type, y = Filling.Mass) # <1>
) +
  geom_point( # <2>
    size = 2 # <3>
  ) +
  labs(
    # title = "Strip Chart of Oreo Filling Mass by Type",
    x = "Type",
    y = "Filling mass (g)"
  ) +
  theme_bw()

```
1. We need to specify the mapping for *each* attribute we want to use.
2. We want to plot a glyph for each case; the point geometry (`geom_point`) does just that.
3. The `size` argument allows us to change the size of the points.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=strip1LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

@fig-strip1 shows why we call such plots strip: we get a long, narrow set of points. These plot allow us to start looking at how similar/different cases are from each other both within their groupings and across groupings. Here, a categorical/qualitative attribute such as type of Oreo is what creates the groupings. Notice that we can't see each individual point (as in a dot plot). Cookies that share the same type and have either the same or very similar amounts of filling will end up lying on top of each other.

:::{.callout-tip}
If you want to make sure that you can see each point, you can do so by adding a small amount of jitter to each point just in the plot. This can be achieved by using the jitter geometry (`geom_jitter`) instead of the point geometry OR by using the argument `position = "jitter"` in `geom_point`. Keep in mind that you might need to adjust the amount of jitter in both horizontal and vertical dimensions to match your needs.
:::

### Scatter Plots

While a strip chart pairs a quantitative attribute with a categorical/qualitative one, a scatter plot pairs two quantitative attributes. 

```{r}
#| label: fig-scatter1
#| fig-cap: "Scatter plot of Bill Length by Bill Depth"
#| fig-alt: "Scatter plot of penguin bill length and bill depth"
#| fig-height: 3
#| echo: true
#| aria-describedby: scatter1LD
# Scatter plot of penguin bill length by depth ----
ggplot(
  data = penguins,
  mapping = aes(x = bill_depth_mm, y = bill_length_mm)
) +
  geom_point( 
    size = 2,
    na.rm = TRUE # <1>
  ) +
  labs(
    # title = ""Scatter plot of Bill Length by Bill Depth",
    x = "Bill depth (mm)",
    y = "Bill length (mm)"
  ) +
  theme_bw()

```
1. There are two penguins who don't have a recorded bill depth and/or length; this argument will remove those cases without a printed warning. By default, `ggplot` will remove the missing cases and print a warning message that it did so.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=scatter1LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

The code to create @fig-scatter1 is essentially the same as a strip chart. The only difference is that instead of mapping a one quantitative attribute and one qualitative attribute we mapped two quantitative attributes. 

We can actually go further by incorporating a third attribute if we desire. Let's recreate @fig-scatter1 but add the species attribute.

```{r}
#| label: fig-scatter2
#| fig-cap: "Scatter plot of Bill Length by Bill Depth and Species"
#| fig-alt: "Scatter plot of penguin bill length and bill depth by species"
#| fig-height: 3
#| echo: true
#| aria-describedby: scatter2LD
# Scatter plot of penguin bill length by depth and species ----
ggplot(
  data = penguins,
  mapping = aes(
    x = bill_depth_mm,
    y = bill_length_mm,
    color = species, # <1>
    shape = species # <2>
  )
) +
  geom_point( 
    size = 1,
    na.rm = TRUE 
  ) +
  labs(
    # title = ""Scatter plot of Bill Length by Bill Depth and Species",
    x = "Bill depth (mm)",
    y = "Bill length (mm)",
    color = "Species",
    shape = "Species"
  ) +
  theme_bw()

```
1. We will map the species case attribute to the color aesthetic.
2. For accessibility, you should always try to partner color with a second aesthetic such as shape.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=scatter2LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

@fig-scatter2 revels how bill length and depth relate to each other in the presence of penguin species.

### Multivariate Box Plots

We can also apply additional attributes to box/schematic plots.

```{r}
#| label: fig-box3
#| fig-cap: "Side-by-Side Box Plots of Filling Mass by Type"
#| fig-alt: "Several schematic plots for the filling mass of oreos by type"
#| fig-height: 4
#| echo: true
#| aria-describedby: box3LD
# Side-by-side schematic plots of Oreo filling mass by type----
ggplot(
  data = oreoData,
  mapping = aes(x = Type, y = Filling.Mass, fill = Type)  # <1>
) +
  geom_boxplot(
    coef = 1.5
  ) +
  labs(
    # title = "Side-by-Side Box Plots of Filling Mass by Type",
    x = "Type",
    y = "Filling mass (g)"
  ) +
  theme_bw() 

```
1. Here I'm mapping Oreo type to both the horizontal axis (`x`) and to the color of the boxes (`fill`).

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=box3LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

@fig-box3 gives an example of side-by-side box plots (technically, schematic plots) for filling mass of Oreos broken down by type.

## Using Multiple Layers

The graphics that we create using `{ggplot2}` are very customizable and can allow us to do many things. One thing that we can do is layer multiple geometries on top of one another. This can allow us to leverage the strengths of different geometries to make up for the weaknesses of others. Consider 

```{r}
#| label: fig-box4
#| fig-cap: "Box plot of Filling Mass"
#| fig-alt: "Box plot of Oreo filling mass with cases showing"
#| fig-height: 3
#| echo: true
#| aria-describedby: box4LD
# Box plot of Oreo filling masses with individual cases ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass) 
) +
  geom_boxplot( # <1>
    coef = Inf
  ) +
  geom_jitter( # <2>
    mapping = aes(y = 0), # <3>
    width = 0, # <4>
    height = 0.1 # <5>
  ) +
  labs(
    # title = "Box plot of Filling Mass",
    x = "Type",
    y = "Filling mass (g)"
  ) +
  theme_bw() 

```
1. The first layer to our figure will be a [standard] box plot.
2. The second layer will place glyphs for each cookie via the jitter geometry.
3. We need to add a second quantity for `geom_jitter` to function. A horizontal box plot is centered around `y = 0`, thus we will give all points this initial `y` value.
4. The `width` argument controls how far to move a case horizontally. By setting this to zero, we will preserve each case's true value for the attribute on the horizontal axis (i.e., filling mass).
5. The `height` argument controls how far to move a case vertically. Since the vertical axis does not represent any aspect of our cookies, this is the best dimension to shift the glyphs. Glyphs will be shifted a random amount up to the value we list.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=box4LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

@fig-box4 allow us to draw upon all of the strengths of a [standard] box plot while also getting to see where the individual cases fall. 

:::{.callout-caution}
Layering geometries can be useful but can also be overdone. With any data visualization that you create, always to a few moments to critically examine the end result. Is the visualization useful? Too busy? Too hard to understand? If so, adjust.
:::

## Quantile-Quantile Plots

Quantile-Quantile plots, also known as QQ Plots are an interesting type of visualization. QQ plots consist of multiple attributes that are derived from the single case attribute we use as an input. The `{car}` package has one of the best implementations of QQ plots that I've come across.

```{r}
#| label: fig-qq1
#| fig-cap: "QQ plot for Oreo Filling Mass"
#| fig-alt: "QQ plot of oreo filling mass"
#| fig-height: 4
#| echo: true
#| aria-describedby: qq1LD
# QQ Plots using the {car} package ----
car::qqPlot( # <1>
  x = oreoData$Filling.Mass, # <2>
  distribution = "norm", # <3>
  envelope = 0.90, # <4>
  id = FALSE, # <5>
  pch = 19,
  ylab = "Empirical quantiles"
)
```
1. We use the `qqPlot` function to create a QQ plot.
2. We must provide the case attribute that we want to use.
3. The `distribution` argument is where we can specify which named distribution we want to check our data against. The default is the Gaussian (or "Normal") distribution with the value `"norm"`.
4. The `{car}` package allows use to add a confidence envelope by setting the `envelope` argument to either a number (representing the confidence level) or to `FALSE` to turn off the envelope.
5. The `id` argument toggles whether to show the two cases that depart the most from the reference line (`TRUE`). These points will be labelled by their row number. `FALSE` does not id the points

```{=html}
<details id=qq1LD open>
  <summary>Long Description</summary>
  <p>needs to be manually written</p>
</details>
```

@fig-qq1 shows a QQ plot for the Oreo filling masses (across both types) when compared to a Gaussian (or "Normal") distribution. While each dot in the QQ plot represents a cookie, neither axis represents the filling mass. The horizontal axis, labelled "norm quantiles", represents the quantile value that was assigned to each cookie based upon our chosen theoretical distribution. The vertical axis, labelled "Empirical quantiles", represents the quantile value that each cookie had given the sample. As a second layer, a solid blue comparison line is plotted. If the points all fall on this line, then we have a perfect match between what we've observed and theory. The confidence envelope helps us deal with the reality almost nothing is perfect. The envelope helps us develop some sense of how far from the comparison line is too far way; that is, outside the shaded envelope. We will discuss how to interpret QQ plots more in-depth later in the course.


## Customizations of Plots

There are many ways in which you can customize plots created with the `ggplot` command. Check out the package's documentation as well as exploring examples there and online.

One of the most common ways that people customize plots is by choosing their own colors. Always try to pick a color palette that is color-blind friendly. There are multiple packages for R that provide new color palettes. If you want a Penn State themed palette, feel free to use the following `psuPalette`.

```{r}
#| label: fig-scatter3
#| fig-cap: "Scatter plot of Bill Length by Bill Depth and Species"
#| fig-alt: "Scatter plot of penguin bill length and bill depth by species"
#| fig-height: 4
#| echo: true
#| aria-describedby: scatter3LD
# Define the psuPalette ---- # <1>
psuPalette <- c(
  "#1E407C", "#BC204B", "#3EA39E", "#E98300",
  "#999999", "#AC8DCE", "#F2665E", "#99CC00"
) 

# Scatter plot of penguin bill length by depth and species ----
ggplot(
  data = penguins,
  mapping = aes(
    x = bill_depth_mm,
    y = bill_length_mm,
    color = species,
    shape = species
  )
) +
  geom_point( 
    size = 2,
    na.rm = TRUE 
  ) +
  labs(
    # title = "Scatter plot of Bill Length by Bill Depth and Species",
    x = "Bill depth (mm)",
    y = "Bill length (mm)",
    color = "Species",
    shape = "Species"
  ) +
  theme_bw() +
  scale_color_manual(
    values = psuPalette # <2>
  )

```
1. You just need to define this object once in your script. Then you can call the palette any where in your code after the definition.
2. Here's how you would apply your custom palette to the color aesthetic. If you wanted to apply the palette to the fill aesthetic, you would use the `scale_fill_manual` command.

```{r}
description <- BrailleR::VI(x = last_plot())
```

```{=html}
<details id=scatter3LD>
  <summary>Long Description</summary>
  `r paste(description$text, collapse = " ")`
  <p><em>Description automatically generated by the {BrailleR} package.</em></p>
</details>
```

Always balance creating glitzy visualizations with their usefulness. Visualizations that become too pretty/fancy lose much of their utility for helping people build their understandings of the underlying phenomenon.

## A Data Visualization Explorer

Working with code can be challenging to get started. Luckily, the "dreamRs" group (Victor Perrier and Fanny Meyer) have created a tool that allows you to use a drag-and-drop platform to create data visualizations. This tool is found in the package `{esquisse}` (French for sketch). One of the great aspects of this tool is that it will also create R code for you to be able to re-create the data visualization you make in the tool.

```{r}
#| label: esquisse1
#| echo: true
#| eval: false
# Using esquisse ----
# install.packages("esquisse") # <1>

library(esquisse) # <2>
esquisser(
  data = oreoData, # <3>
  viewer = "browser" # <4>
)

```
1. You will need to install the `{esquisse}` package first if you don't already have it. (Not covered by the `checkSetup` function.)
2. Load the package.
3. The only required argument to the tool (`esquisser`) is the `data` argument. This should be the already loaded (and cleaned) data that you want to use.
4. The `viewer` argument is optional. By default a new window will appear inside of your IDE. You can direct the tool to use a new tab in your default browser instead. If you are using the base R app, the command will go to your browser.

### Cautions on `esquisser`

There are a couple of things to be aware of when you use the `esquisser` tool. First, when the tool is running, you will not be able to submit any other commands to your console. You'll have to completely close the tool to regain use of the console.

Second, __do not__ run the `esquisser` tool inside of a Markdown-enabled document. Too often when people do this they forget to comment out, disable, or otherwise remove the command. Then when they go to knit/render their document, the process hangs and does not finish. Essentially, the `esquisser` command disrupts the knitting/rendering process. Use this tool in either a R script or directly in the console.

# Creating Figures in Markdown-Enabled Documents

When you are writing statistical reports, you'll always want to include some data visualizations. Keep in mind that for Stat 461, you may use any document creation software you wish including Microsoft Word and Google Docs. Just remember that you'll need to submit either PDF or DOCX files to Canvas.

Markdown-enabled documents such as R Markdown and Quarto documents can create PDFs and DOCX files for you. The benefit of using Markdown-enabled files is that you can keep all of your narrative text and code together in one file. This cuts down on any potential issues where you might copy/paste the an outdated figure into your Word document OR you put in a low-quality screenshot that makes the figure hard to read.

:::{.callout-tip}
If you are using Word or Docs to make your reports, please make sure that you use the built-in tools to either your IDE (RStudio Desktop) or functions such as `ggsave` to export your plots in high quality. Avoid using screenshot tools.
:::

## Figure Code Chunks

The key to making a figure in a Markdown-enabled document is to do so in a code chunk. Each code chunk will correspond to one figure environment. Regardless of whether you use R Markdown or Quarto, each figure code chunk will have to have 1) the code to make the plot/graph, and 2) the appropriate figure options. Your plot/graph code will be the same in either system, how you specify the options is what is different. 

To demonstrate how to set up the code chunks, I'll use @fig-scatter3 as my example.

Here's what the code chunk would look like for __R Markdown__:

```{{r scatter3}}
#| fig.cap = "Scatter plot of Bill Length by Bill Depth and Species",
#| fig.alt = "Scatter plot of penguin bill length and bill depth by species",
#| fig.height = 4, 
#| fig.align = "center",
#| fig.pos = "H"

# Code for the plot goes here...
```

And here is what the code chunk looks like for __Quarto__:

```{{r}}
#| label: fig-scatter3
#| fig-cap: "Scatter plot of Bill Length by Bill Depth and Species"
#| fig-alt: "Scatter plot of penguin bill length and bill depth by species"
#| fig-height: 4
#| fig-align: center
#| fig-pos: H

# Code for the plot goes here...
```

Here's a quick run down of the major differences:

1. R Markdown uses a period (`.`) while Quarto uses a dash (`-`) to separate the figure abbreviation (`fig`) from the option.
2. R Markdown uses equal signs to assign a value (on the right) to the figure option (on the left). Quarto uses the colon instead.
3. The chunk name/label appear inside the curly braces for R Markdown while the name/label appears as the first chunk option (`label:`).
4. Quarto requires starting the label of a figure with `fig-`, if you want to use cross-referencing.
5. R Markdown requires commas at the end of each chunk option except the last.
6. R Markdown's figure alignment and position arguments (`fig.align` and `fig.pos`) need to be listed in quotation marks while Quarto's do not.

## Figure Options

There are numerous options pertaining to figures that you can set up in your code chunks. I'm only going to cover the most important/useful ones.

### Figure Names & Cross-Referencing

One of the most powerful tools to take advantage is automated figure numbering and cross-referencing. This capability isn't unique to Markdown-enabled documents; Microsoft Word and Google Docs have menus that will help you do this as well. However, to make use of this in R Markdown and Quarto you will need to give each code chunk that creates a figure a unique name. Follow sound naming guidelines (e.g., no spaces, no starting with a number, no special characters, etc.). You can use a dash, `-`, in the names as needed. These unique names are what allows the system to automatically number each figure appropriately as well as allow you to build cross-references into your narrative text.

For R markdown documents, you type "Figure `\ref{fig:scatter3}`" (without quotation marks) to place the appropriate figure number (reference) into your text. In Quarto documents you type "`@fig-scatter3`" (without quotation marks). Notice that in both cases you make use of the code chunk's name/label. 

### Captions

While giving the code chunk a name should trigger the numbering of the figure, you should provide each figure with an appropriate caption. This is done by giving a character string to the `fig.cap`/`fig-cap` option. This will get displayed along with the figure. If you are NOT using figure captions, then you must include a title in each plot/graph.

#### Sub-figures

If you are creating a figure that contains multiple plots/graphs, then you should not only include an overall figure caption but also sub-captions. In R Markdown, you would add these sub-captions as a character vector to the `fig.subcap` option:

```{{r multiFigExample}}
#| fig.cap = "Overall Figure Caption"
#| fig.subcap = c("Sub caption for first plot", "Sub caption for next plot")
#| fig.ncol = 2,
#| out.width = "50%"

# Code for all sub plots would follow...
```

In Quarto you would use the following:

```{{r}}
#| label: fig-multiFigExample
#| fig-cap: "Overall Figure Caption"
#| fig-subcap:
#|   - "Sub caption for first plot"
#|   - "Sub caption for the next plot"
#| layout-ncol: 2

# Code for all sub plots would follow...
```

The additional options (`fig.ncol`/`layout-ncol` and `out.width`) are ways to help arrange the sub-figures. If you wanted to reference the specific sub-figure instead of the the set, you type the following:

+ __R Markdown__: "Figure `\ref{fig:multiFigExample-#}`" (no quotation marks)
+ __Quarto__: "`@fig-multiFigExample-#`" (no quotation marks)

In both cases, replace the octothrope, `#`, with the appropriate numeral that reflects which sub-figure you want: 1 for the first; 2 for the second, etc.

:::{.callout-tip}
### Alt Text via `fig.alt`/`fig-alt`
While not required in this class, you can make your statistical reports more accessible by including alt text on your figures. Alt text is a brief summary of the figure. Generally aim for alt text to be around 150 characters and only take a person 5-10 second to process.

*Applies to HTML outputs only*
:::

### Figure Sizing

You can adjust the size of your figures by using the `fig.height`/`fig-height` and `fig.width`/`fig-width` options. These generally take a numeric value that is translated as a number of inches. I generally recommend setting either the width OR the height but not both. This better allows for the knitting/rendering process to scale the figure and preserve the aspect ratio. If you specify both height and width, the aspect ratio will be altered leading to image distortion. You may need to play around with numeric values to find what works best for each plot individually.

### Figure Alignment

Just like text, we can choose several different alignments for figures. We can put the figure at the left edge of the page or right edge of the page (known as left and right alignments, respectively.) The most common alignment for figures is to center the figure on the page horizontally; this is known as center alignment. We use the `fig.align`/`fig-align` option to set this.

### Figure Position

We can also specify where we want the figure to appear vertically in the document. Just as with tables, the notion of pages comes into play for the placement of figures. To try to get the plot to appear as close to same relative position as the code chunk, you'll use the `fig.pos`/`fig-pos` option with the value `H` (with quotation marks for R Markdown). Keep in mind that the knitting/rendering process will attempt to follow this request unless there is not enough space on the page for the figure.

## Set Global Figure Options

Some figure options are best set individually for each figure (e.g., sizing options); others are best set globally for the entire document (e.g., alignment and positioning). 

Any option that you set globally does not need to be listed in the individual code chunks---unless you want to change that option for a particular chunk. 

__For R Markdown documents__, you can include the following code chunk at the top of your document, after the YAML header:

```{{r setOptions}}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.align = "center",
  fig.pos = "H"
)
```

__For Quarto documents__, you can set these options in your YAML header:

``` yaml
---
format: 
  pdf: 
    fig-align: center
    fig-pos: H
    cap-location: top
execute: 
  echo: false
  warning: false
---
```

{{< pagebreak >}}

# Code Appendix

```{r codeAppend, ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```