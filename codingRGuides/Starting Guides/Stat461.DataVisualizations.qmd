---
title: "Data Visualizations"
author: "Neil J. Hatfield"
date-modified: now
latex-tinytex: true
format: 
  html:
    embed-resources: true
    number-sections: true
    code-annotations: below
    fig-align: center
    toc: true
    toc-depth: 4
    toc-location: right
    cap-location: top
    link-external-newwindow: true
execute: 
  echo: false
  warning: false
  cache: true
---

Welcome! This Getting Started guide focuses on Data Visualizations. I've woven R code with some key guidance and conventions throughout. Thus, even if you are not using R, I highly recommend that you read through the guide. If you are using R, I'll encourage you to try to mimic the code for yourself and recreate the examples. Then you can adapt the code to help you with other data collections (say, the data from HW #1.1).

An important think to remember as you read this guide is that this guide is *not* meant to be exhaustive. I am not going to cover every possible type of data visualization nor am I going to cover every possible way to create the same kind of data visualization in R. 

# Getting Ready

When getting ready to do anything in R, you'll always want to take a moment and ensure that you identify what packages and data you'll need. Then you should load those items. Again, a good habit to get into is to always start your R script (or your first code chunk) by loading packages, setting any global options, and loading data.

## Graphics Packages

When you use a statistical software package like Minitab, SPSS, JMP, or a spreadsheet program like Excel or Sheets, you are typically limited to the visualization tools in that program. In R, that isn't the case. There are many packages you can use to create data visualizations.  There are many packages that are dedicated to extending the graphing capabilities of base R such as `{ggplot2}`, `{lattice}`, `{plotly}`, `{Rgraphviz}`, and `{scatterplot3d}` to list a few. In addition to these, many packages will often contain functions that will create specialized graphs (e.g., the `qqPlot` function from the `{car}` package).

I'm going to focus on using the `{ggplot2}` package that is part of the `{tidyverse}`. This package has many nice tools and creates some nice looking data visualizations. I'll also make use of the `{car}` package.

```{r}
#| label: loadPackages
#| echo: true
#| results: hide
# Load useful packages ----
packages <- c("tidyverse", "car")
lapply(
  X = packages,
  FUN = library,
  character.only = TRUE,
  quietly = TRUE
)

```

## Load Data

I'm going to use the penguin data from the `{palmerpenguins}` package as well as a version of the Oreo data related to HW #1.1. As a reminder, here's how you load these both into R.

```{r}
#| label: loadData
#| echo: true
# Loading data into my session ----
## Palmer Penguin data
# install.packages("palmerpenguins")  
penguins <- palmerpenguins::penguins 

## Oreo Data (HW #1.1) 
oreoData <- read.table( 
  file = "https://raw.github.com/neilhatfield/STAT461/master/dataFiles/classDemoOreo.dat", 
  header = TRUE,
  sep = ","
) 

```

# Planning

Most people skip over one of the most important steps in creating data visualizations: __planning__. It is very easy to skip this step and jump straight into clicking buttons or running graphing commands. However, good data visualizations demand that not only do you think about the visualization but you think about how you are going to use and talk about what appears in the data visualization. By taking a few minutes to plan your data visualization, you'll be in a better position as a whole.

Here are some questions to ask yourself as you plan your data visualization:

+ What is your goal? What are you trying to do?
+ What data do you need? What data do you have?
    + Is the data tidy? Do you need to wrangle the data first?
+ What kind of visualization do you want to make?
+ What geometry(-ies) do you need for your visualization?
+ What goes into the framework of your visualization?
+ What goes into the content?
+ What do you need in terms of labels and scales?
+ Do you need multiple layers to the visualization?

:::{.callout-tip}
A good practice is to sketch what you're trying to create. This will help you think through the various elements of your visualization. Additionally, this can help you better ask others for help.
:::

## Data Wrangling

An important part of making a plan is to double check that you have the data you need and that the data is in a useful form. For this guide, I'm using the penguins data, which is ready to go, and some Oreo data, which isn't quite ready. The major thing that I need to do for my data is to tell R to treat the type of Oreo as a factor.

```{r}
#| label: makeFactor
#| echo: true
# Set the Type as a Factor ----
oreoData$Type <- as.factor(oreoData$Type)

```

# Creating Data Visualizations

Once you've made a plan, the next step is to actually create the data visualization. If you are using some another statistical software (e.g., Minitab) or spreadsheet program (e.g., Excel), I still encourage you to read the following. Doing so will help you better understand some of the most common kinds of data visualizations.

## Frequency Based Visualizations

One of the most common classes of data visualizations are those that are based upon how often we observe different values for a single case attribute we're interested in. Keep in mind that we can express frequency on several different scales. *Absolute Frequency* refers to a strict counting of cases in each value grouping while *Relative Frequency* measures what percentage or proportion of the data collection has each value. 

### Dot Plots

Perhaps the most simple form of a frequency histogram is that of a dot plot. @fig-dot1 provides an example of such a plot.

```{r}
#| label: fig-dot1
#| fig-cap: "Dot plot of Oreo Filling Mass (g)"
#| fig-alt: "Dots showing the filling mass in grams for 60 Oreos"
#| fig-height: 3
#| echo: true
# Dot Plot of Oreo Filling Mass ----
ggplot(
  data = oreoData, # <1>
  mapping = aes(x = Filling.Mass) # <2>
) +
  geom_dotplot( # <3>
    method = "histodot",
    binwidth = 0.1,
    right = FALSE,
    dotsize = 1
  ) +
  labs( # <4>
    # title = "Dot Plot of Oreo Filling Mass", # <5>
    x = "Filling Mass (g)"
  ) +
  theme_bw() + # <6>
  theme( # <7>
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )

```
1. The `data` argument of the `ggplot` command is how we send data to the visualization.
2. The `mapping` argument allows us to assign a column of our data to an aesthetic (`aes`) such as the horizontal (`x`) axis.
3. In the dot plot geometry (and others), we may need to play around with additional arguments to make the visual look good. 
4. We can define the labels of our plot with the `labs` call.
5. You need to either have a plot title OR a figure caption for every plot. Since I'm using figure captions, I've commented out the title.
6. This is a pre-defined theme that makes a classic background for the plot.
7. You can further customize your plot. Here I'm hiding the vertical (`y`) axis as this is unneeded in a dot plot.

Dot plots such as @fig-dot1 show *absolute frequencies* as each dot (i.e., a glyph) corresponds to a specific case (here, an Oreo cookie). The position of each dot is determined by the filling mass of that cookie. The `binwidth` argument creates bins of 0.1 grams. The cookies that are in the same bin will then stack on top of each other. 

While this visualization allows you to get a big picture view of your data, playing around the with arguments of the geometry (`geom_dotplot`) can be time consuming.

### Bar Charts

Many people are familiar with bar charts; they are a classic type of visualization. We can use either absolute or relative frequencies. An important difference between a bar chart and a dot plot is that bar charts *aggregate* our data. That is, while a dot plot shows the individual cases, the bar chart will hide them. Generally, bar charts are used with attributes that are categorical in nature such as the species of penguins or the type of Oreo.

```{r}
#| label: fig-bar1
#| fig-cap: "Bar plot of Penguin Species"
#| fig-alt: "Bar plot showing the absolute frequencies of penguin species"
#| fig-height: 3
#| echo: true
# Bar Plot of Penguin Species ----
ggplot(
  data = penguins,
  mapping = aes(x = species)
) +
  geom_bar( # <1>
    color = "black", # <2>
    fill = "blue" # <3>
  ) +
  labs(
    # title = "Bar plot of Penguin Species",
    x = "Species",
    y = "Freq."
  ) +
  theme_bw()

```
1. Use the `geom_bar` to create a bar plot.
2. The `color` argument for this geometry controls the color of the piping/edges of the bars.
3. The `fill` argument controls the color of the bars themselves.

@fig-bar1 shows an absolute frequency bar plot for the three species of penguins in the penguin data. Notice that the species appear alphabetically across the axis they were assigned to (the horizontal). This is the default behavior of `ggplot`. You can reverse the order or even impose your own order if you so desire.

If we want to make a relative frequency bar plot, we can do so with a quick adjustment to the code as shown in @fig-bar2.

```{r}
#| label: fig-bar2
#| fig-cap: "Relative Frequency Bar plot of Penguin Species"
#| fig-alt: "Bar plot showing the relative frequencies of penguin species"
#| fig-height: 3
#| echo: true
# Bar Plot of Penguin Species ----
ggplot(
  data = penguins,
  mapping = aes(x = species, y = after_stat(prop), group = 1) # <1>
) +
  geom_bar(
    color = "black",
    fill = "blue"
  ) +
  labs(
    # title = "Relative Frequency Bar plot of Penguin Species",
    x = "Species",
    y = "Relative Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    labels = scales::percent, # <2>
    expand = expansion(add = c(0, 0.03)) # <3>
  )

```
1. By specifying `y = after_stat(prop)` we tell R that we want relative frequencies (or proportions). To set the appropriate denominator, we use `group = 1` to combine all cases into one group.
2. The `labels` argument allows us to adjust the labels on the vertical axis. The `{scales}` package has an automated function for showing percentages.
3. The `expand` argument allows us to control buffer space above/below (or left/right) of our data. Here, I'm *adding* zero buffer below the bars and a 3% buffer above the top of the highest bar.

Something to notice is that @fig-bar1 and @fig-bar2 look identical to each other up to the scale of the vertical axis. This will be true any time you shift between absolute and relative frequencies: the general appearance will be the same. We like to use relative frequency forms when we need to make comparisons between collections that are not the same size. For example, comparing a set of 60 Oreo cookies to a set of just 20 cookies.

If you incorporate multiple attributes, you can create additional types of bar charts such as side-by-side or stacked bar charts. These are not covered in this guide.

### Histograms

Histograms are very similar to bar charts. In fact, we read the two types of plots in the same way. The key difference is what attributes we want to visualize. While bar charts start with categorical attributes, histograms start out with quantitative attributes (especially, continuous ones). Behind the scenes (i.e., the computer does this) the interval of values gets broken down into a set of bins and we count how many cases fall into each bin. 

```{r}
#| label: fig-hist1
#| fig-cap: "Histogram of Filling Mass"
#| fig-alt: "Histogram of Oreo filling masses"
#| fig-height: 3
#| echo: true
# Histogram of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_histogram( # <1>
    color = "black",
    fill = "blue",
    binwidth = 0.1,
    boundary = 0, # <2>
    closed = "left" # <3>
  ) +
  labs(
    # title = "Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    expand = expansion(add = c(0, 2)) # <4>
  )

```
1. For histograms we use the `geom_histogram` call.
2. The `boundary` argument allows us to set where we want to specify a particular bin edge to be set at. Alternatively, you can use `center` to specify a value you want to be the center of a bin. All other bins will adjust to this.
3. Most people are used to left-closed histograms: each bin contains the left-edge value up to the right-edge but not the right-edge value. By default, `{ggplot2}` does the reverse. This argument follows convention.
4. Here I'm adding two units of space above the tallest bar.

@fig-hist1 is an example histogram using the filling masses of the Oreo data. We can get some general impressions of our data collection and what values we've observed by looking at a histogram. To make a relative frequency histogram, we need to make similar changes as for the bar chart.

```{r}
#| label: fig-hist2
#| fig-cap: "Relative Frequency Histogram of Filling Mass"
#| fig-alt: "Relative Frequency Histogram of Oreo filling masses"
#| fig-height: 3
#| echo: true
# Histogram of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_histogram(
    mapping = aes(y = after_stat(count / sum(count))), # <1>
    color = "black",
    fill = "blue",
    binwidth = 0.1,
    boundary = 0,
    closed = "left"
  ) +
  labs(
    # title = "Relative Frequency Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Relative Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    labels = scales::percent,
    expand = expansion(add = c(0, 0.03))
  )

```
1. A `mapping` call inside `geom_histogram` lets us specify that we want to use the `after_stat` command to generate the relative frequencies for each bin.

#### Choosing Bin Width (Number of Bins)

Much like with dot plots, one of the biggest challenges for producing useful histograms is determining either the number of bins (the `bins` argument) or the width of each bin (the `binwidth` argument). You only need to set one of these two as the choice of one automatically determines the other. By default, `ggplot` will use 30 bins--but will produce a warning message that you should use a better number of bins. You can play around with your choices for either of these arguments and find the value that leads to the clearest histogram.

A statistician and a mathematician worked together to form what is known as the Freedman-Diaconis rule which can help you come up with a potentially useful bin width. You can define this in R as

```{r}
#| label: fdRule
#| echo: true
# Freedman-Diaconis Rule ----
fdRule <- function(x) {
  return(
    ifelse(
      test = IQR(x) == 0,
      yes =  0.1,
      no =  2 * IQR(x) / (length(x)^(1/3))
    )
  )
}
```

We can see this rule in action in @fig-hist3.

```{r}
#| label: fig-hist3
#| fig-cap: "Histogram of Filling Mass"
#| fig-alt: "Histogram of Oreo filling masses using the Freedman-Diaconis rule"
#| fig-height: 3
#| echo: true
# Histogram of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_histogram(
    color = "black",
    fill = "blue",
    binwidth = fdRule, # <1>
    boundary = 0,
    closed = "left"
  ) +
  labs(
    # title = "Relative Frequency Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Relative Freq."
  ) +
  theme_bw() +
  scale_y_continuous(
    expand = expansion(add = c(0, 2))
  )

```
1. Notice that after we've defined the `fdRule` function, we can call the function in the `binwidth` argument instead of assigning a numeric value.

As you compare @fig-hist1 and @fig-hist3, pay attention to how your descriptions change between them. In the former we might talk about the gaps between two groupings of values but in the later there are no longer any gaps. This highlights that your choice of bin width (or number of bins) is consequential. 

:::{.callout-caution}
A common mistake that people make with histograms is to use the histogram to justify a claim that data follow a typical distribution. For example, upon seeing a symmetric, bell-shaped histogram and declaring that the data follow a Gaussian or "Normal" distribution. Unfortunately, this is __NOT__ accurate. At best, we can use a histogram as evidence *against* our data following a particular distribution. A histogram with a strong positive skew would support our claim that the data *do not* follow a Gaussian or "Normal" distribution.
:::

### Pie Charts

Another data visualization that people often mention are pie charts. Pie charts take the notion of a bar chart and plot things in a circular space. While in a bar chart we read the height of the bar to get the frequency value, pie charts work off of angle measures. That is, the measure of the each slices angle reflects the relative proportion of the whole. This pie charts great at relativistic comparisons between values but terrible for getting accurate amounts. A second drawback to pie charts deals with deciding which slice has a larger angle measure when they are close to each other.

If you absolutely want to create a pie chart, you can. However, you will need to do a little bit of data wrangling first.

```{r}
#| label: summarizeSpecies
#| echo: true
# Wrangle Penguin Data for Pie Chart ----
## We will use {dplyr} commands to help us
pieData <- penguins %>%
  group_by(species) %>%
  summarize(
    count = n()
  )

```

The above code allows us to get the counts that we will then use to make the pie chart.

```{r}
#| label: fig-pie1
#| fig-cap: "Pie Chart of Penguin Species"
#| fig-alt: "Pie chart of penguin species"
#| fig-height: 3
#| echo: true
# Pie Chart of Penguin Species ----
ggplot(
  data = pieData,
  mapping = aes(x = "", y = count, fill = species) # <1>
) +
  geom_bar(
    stat = "identity", # <2>
    color = "black" # <3>
  ) +
  coord_polar(theta = "y", start = 0) + # <4>
  labs(
    # title = "Pie Chart of Penguin Species",
    fill = "Species"
  ) + 
  theme_void() # <5>

```
1. We need to specify both an `x` and `y` component, even though the `x` component will be fixed. To color the slices, we need to map the species attribute to the `fill` aesthetic.
2. Given that we've already done the counting, we just need the bar geometry to make use of the values as is. This code achieves this.
3. Just as before the `color` argument will control the edging of the slices. Omit this argument if you don't want any borders.
4. To transform the bars into pie slices, we change to the polar coordinate system (instead of the Cartesian).
5. When making pie charts, use `theme_void`.

### Waffle Plots

A possible alternative to pie charts is to make a "square pie chart" known as a waffle plot. The core idea is to attempt to overcome the shortcomings of pie charts (namely, working with angle measure). In their most basic form, a waffle plot is a grid-like organization of glyphs. Each glyph can either represent an individual case OR could represent a certain proportion of the data collection. To create a waffle plot, you will need to have the `{waffle}` package installed on your machine (this is not covered by my `checkSetup` function).

```{r}
#| label: fig-waffle1
#| fig-cap: "Waffle Plot of Penguin Species"
#| fig-alt: "A proportional waffle plot of penguin species"
#| fig-height: 3
#| echo: true
# Create a waffle plot of penguin species ----
# install.package(waffle)
library(waffle)

ggplot(
  data = pieData,
  mapping = aes(fill = species, values = count)
) +
  geom_waffle( # <1>
    n_rows = 10,
    make_proportional = TRUE
  ) +
  labs(
    # title = "Waffle Plot of Penguin Species",
    fill = "Species"
  ) +
  theme_void() +
  coord_equal() # <2>

```
1. To use the waffle geometry, you must first install and load the `{waffle}` package.
2. To ensure that glyphs look square, we use the `coord_equal` command.


@fig-waffle1 shows a waffle plot for the penguins species data. For this visualization, I've opted to to the proportion route (via the `make_proportional = TRUE` argument). This means that each square in my 10 X 10 grid represents one percent of the data collection. If we instead wanted each square to represent an individual penguin, I'd use `make_proportional = FALSE` as shown in @fig-waffle2.

```{r}
#| label: fig-waffle2
#| fig-cap: "Waffle Plot of Penguin Species"
#| fig-alt: "A case-based waffle plot of penguin species"
#| fig-height: 3
#| echo: true
# Create a waffle plot of penguin species ----
# install.package(waffle)
library(waffle)

ggplot(
  data = pieData,
  mapping = aes(fill = species, values = count)
) +
  geom_waffle(
    n_rows = 8, # <1>
    make_proportional = FALSE
  ) +
  labs(
    # title = "Waffle Plot of Penguin Species",
    fill = "Species"
  ) +
  theme_void() +
  coord_equal()

```
1. We can alter how many rows appear in the waffle plot. I changed to 8 since 344 (the sample size of the penguin data) is a multiple of 8.

Waffle plots can allow us to see the break down of our data collection along the lines of qualitative/categorical attributes, much like a bar chart.

### Density Based Visualizations

A close cousin of the histogram is a density plot. Whereas a histogram shows the absolute/relative frequency of cases within different bins for a given sample, a density plot attempts to show the probability density for the underlying quantitative attribute. 

```{r}
#| label: fig-density1
#| fig-cap: "Density Plot of Filling Mass"
#| fig-alt: "Density plot of Oreo filling masses"
#| fig-height: 3
#| echo: true
# Density plot of Filling Mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass)
) +
  geom_density( # <1>
    color = "black",
    fill = "blue"
  ) +
  labs(
    # title = "Relative Frequency Histogram of Filling Mass",
    x = "Fillng Mass (g)",
    y = "Density"
  ) +
  theme_bw() +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.05)) # <2>
  ) 

```
1. For density plots, use the `geom_density`.
2. Instead of adding a fixed amount of buffer you can also use a multiplier. Here, I'm expanding the upper bound by 5%.

@fig-density1 shows the density plot for the Oreo filling masses. You'll notice that at the left and right edges there are hard stops to the plot. By default the density plot will stop at the lower and upper extrema in the data. If you want to have the smoothing continue on, you'll need to adjust the limits with an additional command such as `scale_x_continuous(limits = c(lb, ub))` where you replace `lb` and `ub` with the numeric values for the new lower and upper bounds, respectively.

Density plots do not suffer from the same sensitivity to bin width as histograms do. However, they still limits. Inside of the `geom_density` there is an option that controls an aspect called bandwidth (`bw`). We can think about bandwidth as a way of adjusting how much of the data we look at to make the smooth curve as we move through the domain of filling masses. If we make bandwidth very large, then we use more the data making a shallow curve. If we use a small bandwidth, then we use less data, making the curve more spiked. A second important option in `geom_density` is the `kernel`. This is the function that gets used to help make the smooth curve; different kernels will result in different density plots for the same data.

:::{.callout-note}
Digging into both bandwidth and kernel choices are beyond what is necessary for Stat 461. For any instances in our class, use the defaults for these is sufficient.
:::

## Structural Visualizations

The preceding kinds of data visualizations draw upon frequency of case occurrence. These count-based aspects work well with attributes that are categorical/qualitative or quantitative in nature. Suppose that we wanted to draw upon the inherent ordering of the underlying case attribute to help us learn more about our data. When we used the frequency-based visualizations with quantities, the conventions of how we plot kicked in help put the values of the case attribute into numeric order. However, there is a kind of data visualization that was originally created to help highlight the ordinal structure: the box plot.

Many people often think about the box plot as just a visual representation of [Tukey's] Five Number Summery. The standard box plot does show these values but the purpose is to show much, much more.

### The [Standard] Box Plot

```{r}
#| label: fig-box1
#| fig-cap: "[Standard] Box Plot for Filling Mass"
#| fig-alt: "A standard box plot for the filling mass of oreos"
#| fig-height: 3
#| echo: true
# Standard box plot of Oreo filling mass ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass) 
) +
  geom_boxplot( # <1>
    coef = Inf, # <2>
    staplewidth = 0.1 # <3>
  ) +
  labs(
    # title = "[Standard] Box Plot for Filling Mass",
    x = "Filling mass (g)",
    y = NULL # <4>
  ) +
  theme_bw() +
  theme( # <5>
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line.y = element_blank()
  )

```
1. To invoke the box plot geometry we use the `geom_boxplot` command.
2. For a [standard] box plot set `coef = Inf`.
3. Traditionally, whiskers end with hash marks called staples. However, more modern box plots do away with them (the default). If you want them you can use the `staplewidth` argument as shown here.
4. For a horizontal box plot, map the case attribute to `x` and tell `y` to have no (`NULL`) label. If you want a vertical box plot, use swap `x` and `y` in the code.
5. These command will make a cleaner box plot by getting rid of elements that don't have any meaning. For a vertical box plot, change the `.y` to `.x` as you swap the other `x` and `y` references.

@fig-box1 is a standard box plot in the sense that the whiskers (the lines) extend to the values of the *Sample Minimum* ($Q_0$) and *Sample Maximum* ($Q_4$). A box plot demonstrates the structure of a data collection in multiple ways. First, we can observe how the data collection lies across the continuum of the case attribute (much like a histogram does). Second, the box plot also shows us what portions of the continuum of values are captured by each of the ordered quarters of the collection. In @fig-box1, the first quarter covers the intervals $[2.25, 3.25]$, approximately. The third quarter approximately covers $[4.55, 6.4]$. We can do the same with the second and fourth quarters. Third, we can use where the quarters lie along with the fact that they contain *roughly* the same number of cases talk about density. The first quarter is more dense than the third quarter, suggesting that the first quarter has less variation between the cases than the third quarter. Finally, we can also use the box plot to get a sense of symmetry by comparing the two halves of the plot. We can split the box plot along the the thicker black line inside of the box that represents the value of the *Sample Median*). @fig-box1 shows that the filling masses of Oreos might have a some positive skewness (we need to cover more the filling mass axis for values larger than the value of the *Sample Median*).

### Outlier Box Plots (Schematic Plots)

A second form of box plots is sometimes referred to as an "outlier box plot" although this name is a bit misleading. Tukey original referred to these as *Schematic Plots*. They differ from standard box plots in that the whiskers will no longer reach the values of the *Sample Minimum* and *Sample Maximum*. Rather, they will extend to the appropriate hinge. Any cases whose values are beyond the hinges are considered as *outlying cases*. Such cases are not necessarily [potential] outliers as their classification as outlying depends upon our choice for a multiplier (i.e., the `coef` argument).

```{r}
#| label: fig-box2
#| fig-cap: "Schematic Plot for Filling Mass"
#| fig-alt: "A schematic plot for the oreo filling mass"
#| fig-height: 3
#| echo: true
# Schematic plot of Oreo filling mass ----
## I'm going to add a fake Oreo that has 20 grams of filling
oreoData %>%
  tibble::add_row(Filling.Mass = 20, Type = "Extra") %>% # <1>
ggplot( # <2>
  mapping = aes(x = Filling.Mass) 
) +
  geom_boxplot(
    coef = 1.5 # <3>
  ) +
  labs(
    # title = "Schematic Plot for Penguin Body Mass",
    x = "Filling mass (g)",
    y = NULL
  ) +
  theme_bw() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line.y = element_blank()
  )

```
1. Given how I've used the `add_row` command, the extra row only exists in this one bit of code and isn't permanently added to the data.
2. As I am piping in the data frame (via `%>%`), I do not need to list the `data` argument in the `ggplot` call.
3. The most common multiplier is 1.5 but you can use other values if you so choose.

@fig-box2 shows the schematic plot for the Oreo filling masses with the addition of a fake Oreo with 20 grams of filling. Notice that this case appears as a black dot in @fig-box2. If we omitted this fake cookie, our schematic plot would actually look just like the standard box plot of @fig-box1. Any time that there are no outlying cases under your choice of rule, the schematic plot will automatically revert to a standard box plot.

### Other Variations of the Box Plot

There are a number of additional variations of box plots such as variable width of the boxes, adding notches to the boxes and adding on additional cut points (e.g., the first and seventh octiles). 

## Visualizing Multiple Attributes

The data visualizations that we've looked at so far have all focused on a single case attribute at a time. Much of the time, we have several case attributes and we are wanting to explore the relationship between them. The following visualizations do just that.

### Strip Charts

Let's start by attempting to observe how our cases fall when we look at a quantitative attribute and a categorical/qualitative. A strip chart is a great tool for this.

```{r}
#| label: fig-strip1
#| fig-cap: "Strip Chart of Oreo Filling Mass by Type"
#| fig-alt: "Strip chart of oreo filling mass by type"
#| fig-height: 3
#| echo: true
# Strip chart of Oreo filling mass by type ----
ggplot(
  data = oreoData,
  mapping = aes(x = Type, y = Filling.Mass) # <1>
) +
  geom_point( # <2>
    size = 2 # <3>
  ) +
  labs(
    # title = "Strip Chart of Oreo Filling Mass by Type",
    x = "Type",
    y = "Filling mass (g)"
  ) +
  theme_bw()

```
1. We need to specify the mapping for *each* attribute we want to use.
2. We want to plot a glyph for each case; the point geometry (`geom_point`) does just that.
3. The `size` argument allows us to change the size of the points.

@fig-strip1 shows why we call such plots strip: we get a long, narrow set of points. These plot allow us to start looking at how similar/different cases are from each other both within their groupings and across groupings. Here, a categorical/qualitative attribute such as type of Oreo is what creates the groupings. Notice that we can't see each individual point (as in a dot plot). Cookies that share the same type and have either the same or very similar amounts of filling will end up lying on top of each other.

:::{.callout-tip}
If you want to make sure that you can see each point, you can do so by adding a small amount of jitter to each point just in the plot. This can be achieved by using the jitter geometry (`geom_jitter`) instead of the point geometry OR by using the argument `position = "jitter"` in `geom_point`. Keep in mind that you might need to adjust the amount of jitter in both horizontal and vertical dimensions to match your needs.
:::

### Scatter Plots

While a strip chart pairs a quantitative attribute with a categorical/qualitative one, a scatter plot pairs two quantitative attributes. 

```{r}
#| label: fig-scatter1
#| fig-cap: "Scatter plot of Bill Length by Bill Depth"
#| fig-alt: "Scatter plot of penguin bill length and bill depth"
#| fig-height: 3
#| echo: true
# Scatter plot of penguin bill length by depth ----
ggplot(
  data = penguins,
  mapping = aes(x = bill_depth_mm, y = bill_length_mm)
) +
  geom_point( 
    size = 2,
    na.rm = TRUE # <1>
  ) +
  labs(
    # title = ""Scatter plot of Bill Length by Bill Depth",
    x = "Bill depth (mm)",
    y = "Bill length (mm)"
  ) +
  theme_bw()

```
1. There are two penguins who don't have a recorded bill depth and/or length; this argument will remove those cases without a printed warning. By default, `ggplot` will remove the missing cases and print a warning message that it did so.

The code to create @fig-scatter1 is essentially the same as a strip chart. The only difference is that instead of mapping a one quantitative attribute and one qualitative attribute we mapped two quantitative attributes. 

We can actually go further by incorporating a third attribute if we desire. Let's recreate @fig-scatter1 but add the species attribute.

```{r}
#| label: fig-scatter2
#| fig-cap: "Scatter plot of Bill Length by Bill Depth and Species"
#| fig-alt: "Scatter plot of penguin bill length and bill depth by species"
#| fig-height: 3
#| echo: true
# Scatter plot of penguin bill length by depth and species ----
ggplot(
  data = penguins,
  mapping = aes(
    x = bill_depth_mm,
    y = bill_length_mm,
    color = species, # <1>
    shape = species # <2>
  )
) +
  geom_point( 
    size = 1,
    na.rm = TRUE 
  ) +
  labs(
    # title = ""Scatter plot of Bill Length by Bill Depth and Species",
    x = "Bill depth (mm)",
    y = "Bill length (mm)",
    color = "Species",
    shape = "Species"
  ) +
  theme_bw()

```
1. We will map the species case attribute to the color aesthetic.
2. For accessibility, you should always try to partner color with a second aesthetic such as shape.

@fig-scatter2 revels how bill length and depth relate to each other in the presence of penguin species.

### Multivariate Box Plots

We can also apply additional attributes to box/schematic plots.

```{r}
#| label: fig-box3
#| fig-cap: "Side-by-Side Box Plots of Filling Mass by Type"
#| fig-alt: "Several schematic plots for the filling mass of oreos by type"
#| fig-height: 4
#| echo: true
# Side-by-side schematic plots of Oreo filling mass by type----
ggplot(
  data = oreoData,
  mapping = aes(x = Type, y = Filling.Mass, fill = Type)  # <1>
) +
  geom_boxplot(
    coef = 1.5
  ) +
  labs(
    # title = "Side-by-Side Box Plots of Filling Mass by Type",
    x = "Type",
    y = "Filling mass (g)"
  ) +
  theme_bw() 

```
1. Here I'm mapping Oreo type to both the horizontal axis (`x`) and to the color of the boxes (`fill`).

@fig-box3 gives an example of side-by-side box plots (technically, schematic plots) for filling mass of Oreos broken down by type.

## Using Multiple Layers

The graphics that we create using `{ggplot2}` are very customizable and can allow us to do many things. One thing that we can do is layer multiple geometries on top of one another. This can allow us to leverage the strengths of different geometries to make up for the weaknesses of others. Consider 

```{r}
#| label: fig-box4
#| fig-cap: "Box plot of Filling Mass"
#| fig-alt: "Box plot of Oreo filling mass with cases showing"
#| fig-height: 3
#| echo: true
# Box plot of Oreo filling masses with individual cases ----
ggplot(
  data = oreoData,
  mapping = aes(x = Filling.Mass) 
) +
  geom_boxplot( # <1>
    coef = Inf
  ) +
  geom_jitter( # <2>
    mapping = aes(y = 0), # <3>
    width = 0, # <4>
    height = 0.1 # <5>
  ) +
  labs(
    # title = "Box plot of Filling Mass",
    x = "Type",
    y = "Filling mass (g)"
  ) +
  theme_bw() 

```
1. The first layer to our figure will be a [standard] box plot.
2. The second layer will place glyphs for each cookie via the jitter geometry.
3. We need to add a second quantity for `geom_jitter` to function. A horizontal box plot is centered around `y = 0`, thus we will give all points this initial `y` value.
4. The `width` argument controls how far to move a case horizontally. By setting this to zero, we will preserve each case's true value for the attribute on the horizontal axis (i.e., filling mass).
5. The `height` argument controls how far to move a case vertically. Since the vertical axis does not represent any aspect of our cookies, this is the best dimension to shift the glyphs. Glyphs will be shifted a random amount up to the value we list.

@fig-box4 allow us to draw upon all of the strengths of a [standard] box plot while also getting to see where the individual cases fall. 

:::{.callout-caution}
Layering geometries can be useful but can also be overdone. With any data visualization that you create, always to a few moments to critically examine the end result. Is the visualization useful? Too busy? Too hard to understand? If so, adjust.
:::

## Quantile-Quantile Plots

Quantile-Quantile plots, also known as QQ Plots are an interesting type of visualization. QQ plots consist of multiple attributes that are derived from the single case attribute we use as an input. The `{car}` package has one of the best implementations of QQ plots that I've come across.

```{r}
#| label: fig-qq1
#| fig-cap: "QQ plot for Oreo Filling Mass"
#| fig-alt: "QQ plot of oreo filling mass"
#| fig-height: 4
#| echo: true
# QQ Plots using the {car} package ----
car::qqPlot( # <1>
  x = oreoData$Filling.Mass, # <2>
  distribution = "norm", # <3>
  envelope = 0.90, # <4>
  id = FALSE, # <5>
  pch = 19,
  ylab = "Empirical quantiles"
)
```
1. We use the `qqPlot` function to create a QQ plot.
2. We must provide the case attribute that we want to use.
3. The `distribution` argument is where we can specify which named distribution we want to check our data against. The default is the Gaussian (or "Normal") distribution with the value `"norm"`.
4. The `{car}` package allows use to add a confidence envelope by setting the `envelope` argument to either a number (representing the confidence level) or to `FALSE` to turn off the envelope.
5. The `id` argument toggles whether to show the two cases that depart the most from the reference line (`TRUE`). These points will be labelled by their row number. `FALSE` does not id the points


@fig-qq1 shows a QQ plot for the Oreo filling masses (across both types) when compared to a Gaussian (or "Normal") distribution. While each dot in the QQ plot represents a cookie, neither axis represents the filling mass. The horizontal axis, labelled "norm quantiles", represents the quantile value that was assigned to each cookie based upon our chosen theoretical distribution. The vertical axis, labelled "Empirical quantiles", represents the quantile value that each cookie had given the sample. As a second layer, a solid blue comparison line is plotted. If the points all fall on this line, then we have a perfect match between what we've observed and theory. The confidence envelope helps us deal with the reality almost nothing is perfect. The envelope helps us develop some sense of how far from the comparison line is too far way; that is, outside the shaded envelope. We will discuss how to interpret QQ plots more in-depth later in the course.


## Customizations of Plots

There are many ways in which you can customize plots created with the `ggplot` command. Check out the package's documentation as well as exploring examples there and online.

One of the most common ways that people customize plots is by choosing their own colors. Always try to pick a color palette that is color-blind friendly. There are multiple packages for R that provide new color palettes. If you want a Penn State themed palette, feel free to use the following `psuPalette`.

```{r}
#| label: fig-scatter3
#| fig-cap: "Scatter plot of Bill Length by Bill Depth and Species"
#| fig-alt: "Scatter plot of penguin bill length and bill depth by species"
#| fig-height: 4
#| echo: true
# Define the psuPalette ---- # <1>
psuPalette <- c(
  "#1E407C", "#BC204B", "#3EA39E", "#E98300",
  "#999999", "#AC8DCE", "#F2665E", "#99CC00"
) 

# Scatter plot of penguin bill length by depth and species ----
ggplot(
  data = penguins,
  mapping = aes(
    x = bill_depth_mm,
    y = bill_length_mm,
    color = species,
    shape = species
  )
) +
  geom_point( 
    size = 2,
    na.rm = TRUE 
  ) +
  labs(
    # title = ""Scatter plot of Bill Length by Bill Depth and Species",
    x = "Bill depth (mm)",
    y = "Bill length (mm)",
    color = "Species",
    shape = "Species"
  ) +
  theme_bw() +
  scale_color_manual(
    values = psuPalette # <2>
  )

```
1. You just need to define this object once in your script. Then you can call the palette any where in your code after the definition.
2. Here's how you would apply your custom palette to the color aesthetic. If you wanted to apply the palette to the fill aesthetic, you would use the `scale_fill_manual` command.

Always balance creating glitzy visualizations with their usefulness. Visualizations that become too pretty/fancy lose much of their utility for helping people build their understandings of the underlying phenomenon.

## A Data Visualization Explorer

Working with code can be challenging to get started. Luckily, the "dreamRs" (Victor Perrier and Fanny Meyer) have create a tool that allows you to use a drag-and-drop platform to create data visualizations. This tool is found in the package `{esquisse}` (French for sketch). One of the great aspects of this tool is that it will also create R code for you to be able to re-create the data visualization you make in the tool.

```{r}
#| label: esquisse1
#| echo: true
#| eval: false
# Using esquisse
# install.packages("esquisse") # <1>

library(esquisse) # <2>
esquisser(
  data = oreoData, # <3>
  viewer = "browser" # <4>
)

```
1. You will need to install the `{esquisse}` package first if you don't already have it. (Not covered by the `checkSetup` function.)
2. Load the package.
3. The only required argument to the tool (`esquisser`) is the `data` argument. This should be the already loaded (and cleaned) data that you want to use.
4. The `viewer` argument is optional. By default a new window will appear inside of your IDE. You can direct the tool to use a new tab in your default browser instead. If you are using the base R app, the command will go to your browser.

### Cautions on `esquisser`

There are a couple of things to be aware of when you use the `esquisser` tool. First, when the tool is running, you will not be able to submit any other commands to your console. You'll have to completely close the tool to regain use of the console.

Second, __do not__ run the `esquisser` tool inside of a Markdown-enabled document. Too often when people do this they forget to comment out, disable, or otherwise remove the command. Then when they go to knit/render their document, the process hangs and does not finish. Essentially, the `esquisser` command disrupts the knitting/rendering process. Use this tool in either a R script or directly in the console.

# Creating Figures in Markdown-Enabled Documents

# OLD

# Figure Options in R Markdown

There are a variety of options that you can apply to your data visualizations in R Markdown. If you aren't using R Markdown, your visualizations will appear in the Plots window in the lower-right of RStudio. You can click the Export button and copy the plot to your clipboard or save as a file. You can then put that picture into Word or Google Docs. You will then manipulate the following aspects there.

## Basic Format

All of the figure options in R Markdown will need to be listed in the chunk options for the code chunk that creates the visualization.

When you create a chunk, you should have a some text inside of a set of curly braces immediately after the opening three graves. These are the chunk options. The first thing should be a lower case r to set the language, followed by a space, and then the *unique* name you're going to give that chunk. You will then place a comma after the name and begin listing the options you want. Here are the options for the very first histogram I created in this guide: `{r histEx1, echo=TRUE, eval=TRUE, fig.cap="Histogram of Oreo Créme Filling Mass"}`.

Both `echo` and `eval` don't deal with the visualization, just whether to print the code (`echo`) and run the code (`eval`). You can omit them; the homework template has these predefined for you. However, `fig.cap` is a figure option. If you wanted to include more figure options, you just keep adding to the list: `{r histEx1, fig.align='center', fig.height=3, fig.width=6, fig.cap="QQ plot for Oreo créme filling mass using ggplot2", fig.pos='h'}`. The order does not matter. There are many different ones that you can use but I'm going to focus on what I feel are the most useful ones.

Alternatively, you can list each of the options just after you start a code chunk. You would have something like the following:

```{r altCodeOptions, echo=TRUE, eval=FALSE}
{r histEx1}
#| echo = TRUE,
#| eval = TRUE,
#| fig.cap = "Histogram of Oreo Créme Filling Mass"
```

Each option goes on it's own line, which starts with `#|`. You will need to end each line (except the last) with a comma.

## Alignment

Alignment refers to whether the visualization appears to the left, center, or right of the page horizontally. Almost uniformly, data visualizations should appear centered. To do this, you would need to set `fig.align='center'` in each code chunk where a visualization gets made. However, you can also set this as a standard for your entire document:

```{r defaultEx1, echo=TRUE, eval=FALSE}
# Setting options for your document ----
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.align = "center"
)
```

The above default are part of the homework template and will make all visualizations centered for you.

## Size

There are two aspects to size for a visualization: height and width. All visualizations (including any legends) will be inside of a rectangle hence these two dimensions. The `fig.height` will control how tall this rectangle is while `fig.width` will control how wide. Both of these options are expecting a single number which is understood to be a number of *inches*. Thus, `fig.height=2, fig.width=4` will create a visualization that is 2 inches tall and 4 inches wide.

## Caption

The `fig.cap` option adds a caption to your visualization AND will put "Figure \#" out in front. This is consistent with many publication standards. If you omit the `fig.cap` option, then your visualization will not get a label. In such cases, be sure to add a title to your visualizations.

Your caption should appear in quotation marks just after the equals sign: `fig.cap="QQ plot for Oreo créme filling mass using ggplot2"`. Captions should describe the visualization by stating what kind of visualization and of what data. Try not to be overly wordy with your captions.

### Referencing

One of the most useful aspects about using `fig.cap` is that your figures become numbered and referenceable. Have you ever read something and you come across something like "As shown in Figure 3.1 we can see..."? This is an example of referencing a figure. The computer figures out the appropriate number for you...provided you've set up a caption for the visualization.

In R Markdown, you need to have two things first: you have to name your code chunk and provide something as `fig.cap`. Once you have those things, you can that visualization. Start by typing the word "Figure" and then`\ref{fig:chunkName}`. When you knit your file, R will replace the ref code with the appropriate value. For example, if I were to type "Figure `\ref{fig:histEx1}`", I will get Figure \ref{fig:histEx1}---the reference to the first histogram.

You can add captions, auto numbered labels, and cross references in programs like Word. From the Insert menu select caption to set up what you want. To add a reference to a figure, select Cross-reference from the Insert menu, select the appropriate type and then the correct figure. Do set the cross reference to only include the label and number, not the whole caption.

## Position

The last option I'm going to mention is one of the trickier ones to use; `fig.pos` *attempts* to control of the location of the visualization. When you knit the document, R will attempt to find the optimal location for the visualization. You can attempt to override this by setting the value of `fig.pos`. For example, `fig.pos='h'` says "hey, I want the visualization the appear "here" in my document. R will attempt to do that but if your figure is too large for the space at that place, your visualization will be moved (typically, the top of the next page).

# Final Remarks

Hopefully as you've gone through this guide, you have a better idea of how to make just a few of the many different data visualizations possible in R. Further, I hope that you're getting a better idea of how to use R Markdown to write code to your advantage. Practicing these examples is the best way to improve your fluency. For some additional datasets to work with, feel free to explore the following data sets:

-   Motor Trend Car Road Tests---access with `data(mtcars)`
-   Weight versus Age of Chicks on Different Diets---access with `data(ChickWeight)`
-   Effectiveness of Insect Sprays---access with `data(InsectSprays)`
-   The Iris data set---access with `data(iris)`
-   Palmer Penguin Data---install the `palmerpenguins` package first, then access with `palmerpenguins::penguins`

This concludes this guide to data visualizations in R/RStudio.

{{< pagebreak >}}

# Code Appendix

```{r codeAppend, ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```